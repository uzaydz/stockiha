-- إصلاح الثغرة الأمنية في المصادقة الثنائية
-- المشكلة: دالة verify_totp_code تقبل أي رقم من 6 أرقام بدلاً من التحقق الفعلي

-- أولاً: إنشاء دالة TOTP صحيحة باستخدام خوارزمية HMAC-SHA1
CREATE OR REPLACE FUNCTION verify_totp_code_secure(
    p_secret TEXT,
    p_code TEXT,
    p_window INTEGER DEFAULT 1
) RETURNS BOOLEAN AS $$
DECLARE
    v_current_time BIGINT;
    v_time_step BIGINT := 30; -- 30 ثانية
    v_digits INTEGER := 6;
    v_counter BIGINT;
    v_expected_code TEXT;
    v_i INTEGER;
    v_secret_bytes BYTEA;
    v_counter_bytes BYTEA;
    v_hmac BYTEA;
    v_offset INTEGER;
    v_binary INTEGER;
    v_otp INTEGER;
BEGIN
    -- التحقق من صحة المدخلات
    IF p_secret IS NULL OR p_code IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- التحقق من أن الرمز 6 أرقام
    IF NOT (p_code ~ '^[0-9]{6}$') THEN
        RETURN FALSE;
    END IF;
    
    -- تحويل المفتاح من base32 إلى bytes (مبسط)
    -- في الإنتاج يفضل استخدام مكتبة متخصصة لـ base32
    BEGIN
        v_secret_bytes := decode(upper(p_secret), 'base64');
    EXCEPTION WHEN OTHERS THEN
        -- إذا فشل base64، نحاول hex
        BEGIN
            v_secret_bytes := decode(p_secret, 'hex');
        EXCEPTION WHEN OTHERS THEN
            RETURN FALSE;
        END;
    END;
    
    -- الحصول على الوقت الحالي
    v_current_time := EXTRACT(EPOCH FROM NOW())::BIGINT;
    
    -- التحقق من النافذة الزمنية
    FOR v_i IN -p_window..p_window LOOP
        v_counter := (v_current_time + (v_i * v_time_step)) / v_time_step;
        
        -- تحويل counter إلى 8 bytes big-endian
        v_counter_bytes := E'\\x00\\x00\\x00\\x00' || 
                          chr((v_counter >> 24) & 255)::bytea ||
                          chr((v_counter >> 16) & 255)::bytea ||
                          chr((v_counter >> 8) & 255)::bytea ||
                          chr(v_counter & 255)::bytea;
        
        -- حساب HMAC-SHA1
        v_hmac := hmac(v_counter_bytes, v_secret_bytes, 'sha1');
        
        -- استخراج offset
        v_offset := (get_byte(v_hmac, 19) & 15);
        
        -- استخراج 4 bytes وتحويلها إلى integer
        v_binary := (get_byte(v_hmac, v_offset) & 127) << 24 |
                   (get_byte(v_hmac, v_offset + 1) & 255) << 16 |
                   (get_byte(v_hmac, v_offset + 2) & 255) << 8 |
                   (get_byte(v_hmac, v_offset + 3) & 255);
        
        -- تطبيق modulo للحصول على رمز من 6 أرقام
        v_otp := v_binary % (10^v_digits);
        
        -- تحويل إلى string مع padding
        v_expected_code := lpad(v_otp::TEXT, v_digits, '0');
        
        -- مقارنة الرموز
        IF v_expected_code = p_code THEN
            RETURN TRUE;
        END IF;
    END LOOP;
    
    RETURN FALSE;
    
EXCEPTION WHEN OTHERS THEN
    -- في حالة خطأ، نرفض الرمز
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- إنشاء نسخة احتياطية مؤقتة للدالة القديمة
CREATE OR REPLACE FUNCTION verify_totp_code_old(
    p_secret TEXT,
    p_code TEXT,
    p_window INTEGER DEFAULT 1
) RETURNS BOOLEAN AS $$
BEGIN
    -- الدالة القديمة المعطلة (للمراجعة فقط)
    IF p_code ~ '^[0-9]{6}$' THEN
        RETURN true;
    END IF;
    RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- استبدال الدالة الرئيسية بالنسخة الآمنة
DROP FUNCTION IF EXISTS verify_totp_code(TEXT, TEXT, INTEGER);
CREATE OR REPLACE FUNCTION verify_totp_code(
    p_secret TEXT,
    p_code TEXT,
    p_window INTEGER DEFAULT 1
) RETURNS BOOLEAN AS $$
BEGIN
    -- استخدام الدالة الآمنة الجديدة
    RETURN verify_totp_code_secure(p_secret, p_code, p_window);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- إنشاء دالة احتياطية للحالات الطارئة (تعتمد على client-side verification)
CREATE OR REPLACE FUNCTION verify_2fa_for_login_secure(
    p_user_id UUID,
    p_code TEXT
) RETURNS JSONB AS $$
DECLARE
    v_user_record RECORD;
    v_verification_result BOOLEAN := false;
    v_backup_code_used BOOLEAN := false;
    v_used_codes_array TEXT[];
BEGIN
    -- جلب بيانات المستخدم وإعدادات الأمان
    SELECT 
        u.id,
        u.email,
        u.two_factor_enabled,
        uss.totp_secret,
        uss.backup_codes,
        uss.backup_codes_used
    INTO v_user_record
    FROM users u
    LEFT JOIN user_security_settings uss ON u.id = uss.user_id
    WHERE u.id = p_user_id;
    
    -- التحقق من وجود المستخدم
    IF v_user_record IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'المستخدم غير موجود'
        );
    END IF;
    
    -- التحقق من تفعيل المصادقة الثنائية
    IF NOT COALESCE(v_user_record.two_factor_enabled, false) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'المصادقة الثنائية غير مفعلة لهذا المستخدم'
        );
    END IF;
    
    -- التحقق من رمز TOTP باستخدام الدالة الآمنة
    IF v_user_record.totp_secret IS NOT NULL THEN
        v_verification_result := verify_totp_code_secure(v_user_record.totp_secret, p_code, 1);
    END IF;
    
    -- إذا فشل TOTP، تحقق من backup codes
    IF NOT v_verification_result AND v_user_record.backup_codes IS NOT NULL THEN
        -- تحويل JSONB array إلى TEXT array إذا لزم الأمر
        IF jsonb_typeof(v_user_record.backup_codes) = 'array' THEN
            SELECT array_agg(value::TEXT) 
            INTO v_used_codes_array
            FROM jsonb_array_elements_text(COALESCE(v_user_record.backup_codes_used, '[]'::jsonb));
        ELSE
            v_used_codes_array := v_user_record.backup_codes_used;
        END IF;
        
        -- التحقق من backup codes
        IF v_user_record.backup_codes ? p_code AND 
           NOT (p_code = ANY(COALESCE(v_used_codes_array, ARRAY[]::TEXT[]))) THEN
            v_verification_result := true;
            v_backup_code_used := true;
            
            -- إضافة الرمز إلى قائمة المستخدمة
            UPDATE user_security_settings
            SET backup_codes_used = COALESCE(backup_codes_used, '[]'::jsonb) || to_jsonb(p_code),
                updated_at = NOW()
            WHERE user_id = p_user_id;
        END IF;
    END IF;
    
    -- تسجيل محاولة التحقق
    PERFORM log_security_activity(
        p_user_id,
        '2fa_verification',
        CASE 
            WHEN v_verification_result THEN 'تم التحقق من المصادقة الثنائية بنجاح'
            ELSE 'فشل في التحقق من المصادقة الثنائية'
        END,
        CASE WHEN v_verification_result THEN 'success' ELSE 'failed' END,
        CASE WHEN v_verification_result THEN 'low' ELSE 'high' END,
        NULL,
        NULL,
        jsonb_build_object(
            'backup_code_used', v_backup_code_used,
            'verification_success', v_verification_result,
            'code_length', LENGTH(p_code),
            'security_level', 'enhanced'
        )
    );
    
    RETURN jsonb_build_object(
        'success', v_verification_result,
        'backup_code_used', v_backup_code_used,
        'error', CASE 
            WHEN v_verification_result THEN NULL
            ELSE 'رمز المصادقة الثنائية غير صحيح'
        END
    );
    
EXCEPTION WHEN OTHERS THEN
        -- تسجيل الخطأ للمراجعة
        PERFORM log_security_activity(
            p_user_id,
            '2fa_verification_error',
            'خطأ في التحقق من المصادقة الثنائية: ' || SQLERRM,
            'failed',
            'critical'
        );
        
        RETURN jsonb_build_object(
            'success', false,
            'error', 'حدث خطأ في التحقق من المصادقة الثنائية'
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- استبدال دالة verify_2fa_for_login بالنسخة الآمنة
DROP FUNCTION IF EXISTS verify_2fa_for_login(UUID, TEXT);
CREATE OR REPLACE FUNCTION verify_2fa_for_login(
    p_user_id UUID,
    p_code TEXT
) RETURNS JSONB AS $$
BEGIN
    RETURN verify_2fa_for_login_secure(p_user_id, p_code);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- منح الصلاحيات المناسبة
GRANT EXECUTE ON FUNCTION verify_totp_code(TEXT, TEXT, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION verify_totp_code_secure(TEXT, TEXT, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION verify_2fa_for_login(UUID, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION verify_2fa_for_login_secure(UUID, TEXT) TO authenticated;

-- إضافة تعليق للتوضيح
COMMENT ON FUNCTION verify_totp_code IS 'دالة آمنة للتحقق من رمز TOTP باستخدام خوارزمية HMAC-SHA1 الصحيحة';
COMMENT ON FUNCTION verify_2fa_for_login IS 'دالة آمنة للتحقق من المصادقة الثنائية عند تسجيل الدخول'; 
{"version":3,"file":"worker/node_modules_journeyapps_wa-sqlite_src_examples_AccessHandlePoolVFS_js.umd.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/FacadeVFS.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/VFS.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js"],"sourcesContent":["// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './VFS.js';\n\nconst AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\n// Milliseconds since Julian epoch as a BigInt.\n// https://github.com/sqlite/sqlite/blob/e57527c14f7b7cfa6e32eeab5c549d50c4fa3674/src/os_unix.c#L6872-L6882\nconst UNIX_EPOCH = 24405875n * 8640000n;\n\n// Convenience base class for a JavaScript VFS.\n// The raw xOpen, xRead, etc. function signatures receive only C primitives\n// which aren't easy to work with. This class provides corresponding calls\n// like jOpen, jRead, etc., which receive JavaScript-friendlier arguments\n// such as string, Uint8Array, and DataView.\nexport class FacadeVFS extends VFS.Base {\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    super(name, module);\n  }\n\n  /**\n   * Override to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    // The input argument is a string like \"xOpen\", so convert to \"jOpen\".\n    // Then check if the method exists and is async.\n    const jMethodName = `j${methodName.slice(1)}`;\n    return this[jMethodName] instanceof AsyncFunction;\n  }\n  \n  /**\n   * Return the filename for a file id for use by mixins.\n   * @param {number} pFile \n   * @returns {string}\n   */\n  getFilename(pFile) {\n    throw new Error('unimplemented');\n  }\n\n  /**\n   * @param {string?} filename \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  jOpen(filename, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  jDelete(filename, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jAccess(filename, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {Uint8Array} zOut \n   * @returns {number|Promise<number>}\n   */\n  jFullPathname(filename, zOut) {\n    // Copy the filename to the output buffer.\n    const { read, written } = new TextEncoder().encodeInto(filename, zOut);\n    if (read < filename.length) return VFS.SQLITE_IOERR;\n    if (written >= zOut.length) return VFS.SQLITE_IOERR;\n    zOut[written] = 0;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns {number|Promise<number>}\n   */\n  jGetLastError(zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  jClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jRead(pFile, pData, iOffset) {\n    pData.fill(0);\n    return VFS.SQLITE_IOERR_SHORT_READ;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jWrite(pFile, pData, iOffset) {\n    return VFS.SQLITE_IOERR_WRITE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} size \n   * @returns {number|Promise<number>}\n   */\n  jTruncate(pFile, size) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  jSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pSize\n   * @returns {number|Promise<number>}\n   */\n  jFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jCheckReservedLock(pFile, pResOut) {\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jSectorSize(pFile) {\n    return super.xSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jDeviceCharacteristics(pFile) {\n    return 0;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    const filename = this.#decodeFilename(zName, flags);\n    const pOutFlagsView = this.#makeTypedDataView('Int32', pOutFlags);\n    this['log']?.('jOpen', filename, pFile, '0x' + flags.toString(16));\n    return this.jOpen(filename, pFile, flags, pOutFlagsView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nByte \n   * @param {number} pCharOut\n   * @returns {number|Promise<number>}\n   */\n  xRandomness(pVfs, nByte, pCharOut) {\n    const randomArray = new Uint8Array(nByte);\n    crypto.getRandomValues(randomArray);\n    // Copy randomArray to the WebAssembly memory\n    const buffer = pCharOut; // Pointer to memory in WebAssembly\n    this._module.HEAPU8.set(randomArray, buffer); // Copy randomArray into memory starting at buffer\n    return nByte;\n  }\n\n  /**\n   * Gets the current time as milliseconds since Unix epoch\n   * @param {number} pVfs pointer to the VFS\n   * @param {number} pTime pointer to write the time value\n   * @returns {number} SQLite error code\n   */\n  xCurrentTimeInt64(pVfs, pTime) {\n    // Create a DataView to write the current time\n    const timeView = this.#makeTypedDataView('BigInt64', pTime);\n  \n    const currentTime = BigInt(Date.now());\n    // Convert the current time to milliseconds since Unix epoch\n    const value = UNIX_EPOCH + currentTime;\n    \n    // Write the time value to the pointer location\n    timeView.setBigInt64(0, value, true);\n    \n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    const filename = this._module.UTF8ToString(zName);\n    this['log']?.('jDelete', filename, syncDir);\n    return this.jDelete(filename, syncDir);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jAccess', filename, flags);\n    return this.jAccess(filename, flags, pResOutView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);\n    this['log']?.('jFullPathname', filename, nOut);\n    return this.jFullPathname(filename, zOutArray);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);\n    this['log']?.('jGetLastError', nBuf);\n    return this.jGetLastError(zBufArray);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    this['log']?.('jClose', pFile);\n    return this.jClose(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jRead', pFile, iAmt, iOffset);\n    return this.jRead(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jWrite', pFile, pDataArray, iOffset);\n    return this.jWrite(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    const size = delegalize(sizeLo, sizeHi);\n    this['log']?.('jTruncate', pFile, size);\n    return this.jTruncate(pFile, size);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    this['log']?.('jSync', pFile, flags);\n    return this.jSync(pFile, flags);\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    const pSizeView = this.#makeTypedDataView('BigInt64', pSize);\n    this['log']?.('jFileSize', pFile);\n    return this.jFileSize(pFile, pSizeView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    this['log']?.('jLock', pFile, lockType);\n    return this.jLock(pFile, lockType);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    this['log']?.('jUnlock', pFile, lockType);\n    return this.jUnlock(pFile, lockType);\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jCheckReservedLock', pFile);\n    return this.jCheckReservedLock(pFile, pResOutView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    const pArgView = new DataView(\n      this._module.HEAPU8.buffer,\n      this._module.HEAPU8.byteOffset + pArg);\n    this['log']?.('jFileControl', pFile, op, pArgView);\n    return this.jFileControl(pFile, op, pArgView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    this['log']?.('jSectorSize', pFile);\n    return this.jSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    this['log']?.('jDeviceCharacteristics', pFile);\n    return this.jDeviceCharacteristics(pFile);\n  }\n\n  /**\n   * Wrapped DataView for pointer arguments.\n   * Pointers to a single value are passed using a DataView-like class.\n   * This wrapper class prevents use of incorrect type or endianness, and\n   * reacquires the underlying buffer when the WebAssembly memory is resized.\n   * @param {'Int32'|'BigInt64'} type \n   * @param {number} byteOffset \n   * @returns {DataView}\n   */\n  #makeTypedDataView(type, byteOffset) {\n    // @ts-ignore\n    return new DataViewProxy(this._module, byteOffset, type);\n  }\n\n  /**\n   * Wrapped Uint8Array for buffer arguments.\n   * Memory blocks are passed as a Uint8Array-like class. This wrapper\n   * class reacquires the underlying buffer when the WebAssembly memory\n   * is resized.\n   * @param {number} byteOffset \n   * @param {number} byteLength \n   * @returns {Uint8Array}\n   */\n  #makeDataArray(byteOffset, byteLength) {\n    // @ts-ignore\n    return new Uint8ArrayProxy(this._module, byteOffset, byteLength);\n  }\n\n  #decodeFilename(zName, flags) {\n    if (flags & VFS.SQLITE_OPEN_URI) {\n      // The first null-terminated string is the URI path. Subsequent\n      // strings are query parameter keys and values.\n      // https://www.sqlite.org/c3ref/open.html#urifilenamesinsqlite3open\n      let pName = zName;\n      let state = 1;\n      const charCodes = [];\n      while (state) {\n        const charCode = this._module.HEAPU8[pName++];\n        if (charCode) {\n          charCodes.push(charCode);\n        } else {\n          if (!this._module.HEAPU8[pName]) state = null;\n          switch (state) {\n            case 1: // path\n              charCodes.push('?'.charCodeAt(0));\n              state = 2;\n              break;\n            case 2: // key\n              charCodes.push('='.charCodeAt(0));\n              state = 3;\n              break;\n            case 3: // value\n              charCodes.push('&'.charCodeAt(0));\n              state = 2;\n              break;\n          }\n        }\n      }\n      return  new TextDecoder().decode(new Uint8Array(charCodes));\n    }\n    return zName ? this._module.UTF8ToString(zName) : null;\n  }\n}\n\n// Emscripten \"legalizes\" 64-bit integer arguments by passing them as\n// two 32-bit signed integers.\nfunction delegalize(lo32, hi32) {\n  return (hi32 * 0x100000000) + lo32 + (lo32 < 0 ? 2**32 : 0);\n}\n\n// This class provides a Uint8Array-like interface for a WebAssembly memory\n// buffer. It is used to access memory blocks passed as arguments to\n// xRead, xWrite, etc. The class reacquires the underlying buffer when the\n// WebAssembly memory is resized, which can happen when the memory is\n// detached and resized by the WebAssembly module.\n//\n// Note that although this class implements the same methods as Uint8Array,\n// it is not a real Uint8Array and passing it to functions that expect\n// a Uint8Array may not work. Use subarray() to get a real Uint8Array\n// if needed.\nclass Uint8ArrayProxy {\n  #module;\n\n  #_array = new Uint8Array()\n  get #array() {\n    if (this.#_array.buffer.byteLength === 0) {\n      // WebAssembly memory resize detached the buffer so re-create the\n      // array with the new buffer.\n      this.#_array = this.#module.HEAPU8.subarray(\n        this.byteOffset,\n        this.byteOffset + this.byteLength);\n    }\n    return this.#_array;\n  }\n\n  /**\n   * @param {*} module\n   * @param {number} byteOffset \n   * @param {number} byteLength \n   */\n  constructor(module, byteOffset, byteLength) {\n    this.#module = module;\n    this.byteOffset = byteOffset;\n    this.length = this.byteLength = byteLength;\n  }\n\n  get buffer() {\n    return this.#array.buffer;\n  }\n\n  at(index) {\n    return this.#array.at(index);\n  }\n  copyWithin(target, start, end) {\n    this.#array.copyWithin(target, start, end);\n  }\n  entries() {\n    return this.#array.entries();\n  }\n  every(predicate) {\n    return this.#array.every(predicate);\n  }\n  fill(value, start, end) {\n    this.#array.fill(value, start, end);\n  }\n  filter(predicate) {\n    return this.#array.filter(predicate);\n  }\n  find(predicate) {\n    return this.#array.find(predicate);\n  }\n  findIndex(predicate) {\n    return this.#array.findIndex(predicate);\n  }\n  findLast(predicate) {\n    return this.#array.findLast(predicate);\n  }\n  findLastIndex(predicate) {\n    return this.#array.findLastIndex(predicate);\n  }\n  forEach(callback) {\n    this.#array.forEach(callback);\n  }\n  includes(value, start) {\n    return this.#array.includes(value, start);\n  }\n  indexOf(value, start) {\n    return this.#array.indexOf(value, start);\n  }\n  join(separator) {\n    return this.#array.join(separator);\n  }\n  keys() {\n    return this.#array.keys();\n  }\n  lastIndexOf(value, start) {\n    return this.#array.lastIndexOf(value, start);\n  }\n  map(callback) {\n    return this.#array.map(callback);\n  }\n  reduce(callback, initialValue) {\n    return this.#array.reduce(callback, initialValue);\n  }\n  reduceRight(callback, initialValue) {\n    return this.#array.reduceRight(callback, initialValue);\n  }\n  reverse() {\n    this.#array.reverse();\n  }\n  set(array, offset) {\n    this.#array.set(array, offset);\n  }\n  slice(start, end) {\n    return this.#array.slice(start, end);\n  }\n  some(predicate) {\n    return this.#array.some(predicate);\n  }\n  sort(compareFn) {\n    this.#array.sort(compareFn);\n  }\n  subarray(begin, end) {\n    return this.#array.subarray(begin, end);\n  }\n  toLocaleString(locales, options) {\n    // @ts-ignore\n    return this.#array.toLocaleString(locales, options);\n  }\n  toReversed() {\n    return this.#array.toReversed();\n  }\n  toSorted(compareFn) {\n    return this.#array.toSorted(compareFn);\n  }\n  toString() {\n    return this.#array.toString();\n  }\n  values() {\n    return this.#array.values();\n  }\n  with(index, value) {\n    return this.#array.with(index, value);\n  }\n  [Symbol.iterator]() {\n    return this.#array[Symbol.iterator]();\n  }\n}\n\n// This class provides a DataView-like interface for a WebAssembly memory\n// buffer, restricted to either Int32 or BigInt64 types. It also reacquires\n// the underlying buffer when the WebAssembly memory is resized, which can\n// happen when the memory is detached and resized by the WebAssembly module.\nclass DataViewProxy {\n  #module;\n  #type;\n\n  #_view = new DataView(new ArrayBuffer(0));\n  get #view() {\n    if (this.#_view.buffer.byteLength === 0) {\n      // WebAssembly memory resize detached the buffer so re-create the\n      // view with the new buffer.\n      this.#_view = new DataView(\n        this.#module.HEAPU8.buffer,\n        this.#module.HEAPU8.byteOffset + this.byteOffset);\n    }\n    return this.#_view;\n  }\n\n  /**\n   * @param {*} module\n   * @param {number} byteOffset \n   * @param {'Int32'|'BigInt64'} type\n   */\n  constructor(module, byteOffset, type) {\n    this.#module = module;\n    this.byteOffset = byteOffset;\n    this.#type = type;\n  }\n\n  get buffer() {\n    return this.#view.buffer;\n  }\n  get byteLength() {\n    return this.#type === 'Int32' ? 4 : 8;\n  }\n\n  getInt32(byteOffset, littleEndian) {\n    if (this.#type !== 'Int32') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    return this.#view.getInt32(byteOffset, littleEndian);\n  }\n  setInt32(byteOffset, value, littleEndian) {\n    if (this.#type !== 'Int32') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    this.#view.setInt32(byteOffset, value, littleEndian);\n  }\n  getBigInt64(byteOffset, littleEndian) {\n    if (this.#type !== 'BigInt64') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    return this.#view.getBigInt64(byteOffset, littleEndian);\n  }\n  setBigInt64(byteOffset, value, littleEndian) {\n    if (this.#type !== 'BigInt64') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    this.#view.setBigInt64(byteOffset, value, littleEndian);\n  }\n}","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './sqlite-constants.js';\nexport * from './sqlite-constants.js';\n\nconst DEFAULT_SECTOR_SIZE = 512;\n\n// Base class for a VFS.\nexport class Base {\n  name;\n  mxPathname = 64;\n  _module;\n\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    this.name = name;\n    this._module = module;\n  }\n\n  /**\n   * @returns {void|Promise<void>} \n   */\n  close() {\n  }\n\n  /**\n   * @returns {boolean|Promise<boolean>}\n   */\n  isReady() {\n    return true;\n  }\n\n  /**\n   * Overload in subclasses to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    return false;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    return DEFAULT_SECTOR_SIZE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    return 0;\n  }\n}\n\nexport const FILE_TYPE_MASK = [\n  VFS.SQLITE_OPEN_MAIN_DB,\n  VFS.SQLITE_OPEN_MAIN_JOURNAL,\n  VFS.SQLITE_OPEN_TEMP_DB,\n  VFS.SQLITE_OPEN_TEMP_JOURNAL,\n  VFS.SQLITE_OPEN_TRANSIENT_DB,\n  VFS.SQLITE_OPEN_SUBJOURNAL,\n  VFS.SQLITE_OPEN_SUPER_JOURNAL,\n  VFS.SQLITE_OPEN_WAL\n].reduce((mask, element) => mask | element);","// Copyright 2023 Roy T. Hashimoto. All Rights Reserved.\nimport { FacadeVFS } from '../FacadeVFS.js';\nimport * as VFS from '../VFS.js';\n\nconst SECTOR_SIZE = 4096;\n\n// Each OPFS file begins with a fixed-size header with metadata. The\n// contents of the file follow immediately after the header.\nconst HEADER_MAX_PATH_SIZE = 512;\nconst HEADER_FLAGS_SIZE = 4;\nconst HEADER_DIGEST_SIZE = 8;\nconst HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;\nconst HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;\nconst HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;\nconst HEADER_OFFSET_DATA = SECTOR_SIZE;\n\n// These file types are expected to persist in the file system outside\n// a session. Other files will be removed on VFS start.\nconst PERSISTENT_FILE_TYPES =\n  VFS.SQLITE_OPEN_MAIN_DB |\n  VFS.SQLITE_OPEN_MAIN_JOURNAL |\n  VFS.SQLITE_OPEN_SUPER_JOURNAL |\n  VFS.SQLITE_OPEN_WAL;\n\nconst DEFAULT_CAPACITY = 6;\n\n/**\n * This VFS uses the updated Access Handle API with all synchronous methods\n * on FileSystemSyncAccessHandle (instead of just read and write). It will\n * work with the regular SQLite WebAssembly build, i.e. the one without\n * Asyncify.\n */\nexport class AccessHandlePoolVFS extends FacadeVFS {\n  log = null; //function(...args) { console.log(`[${contextName}]`, ...args) };\n\n  // All the OPFS files the VFS uses are contained in one flat directory\n  // specified in the constructor. No other files should be written here.\n  #directoryPath;\n  #directoryHandle;\n\n  // The OPFS files all have randomly-generated names that do not match\n  // the SQLite files whose data they contain. This map links those names\n  // with their respective OPFS access handles.\n  #mapAccessHandleToName = new Map();\n\n  // When a SQLite file is associated with an OPFS file, that association\n  // is kept in #mapPathToAccessHandle. Each access handle is in exactly\n  // one of #mapPathToAccessHandle or #availableAccessHandles.\n  #mapPathToAccessHandle = new Map();\n  #availableAccessHandles = new Set();\n\n  #mapIdToFile = new Map();\n\n  static async create(name, module) {\n    const vfs = new AccessHandlePoolVFS(name, module);\n    await vfs.isReady();\n    return vfs;\n  }\n  \n  constructor(name, module) {\n    super(name, module);\n    this.#directoryPath = name;\n  }\n\n  /**\n   * @param {string?} zName \n   * @param {number} fileId \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number}\n   */\n  jOpen(zName, fileId, flags, pOutFlags) {\n    try {\n      // First try to open a path that already exists in the file system.\n      const path = zName ? this.#getPath(zName) : Math.random().toString(36);\n      let accessHandle = this.#mapPathToAccessHandle.get(path);\n      if (!accessHandle && (flags & VFS.SQLITE_OPEN_CREATE)) {\n        // File not found so try to create it.\n        if (this.getSize() < this.getCapacity()) {\n          // Choose an unassociated OPFS file from the pool.\n          ([accessHandle] = this.#availableAccessHandles.keys());\n          this.#setAssociatedPath(accessHandle, path, flags);\n        } else {\n          // Out of unassociated files. This can be fixed by calling\n          // addCapacity() from the application.\n          throw new Error('cannot create file');\n        }\n      }\n      if (!accessHandle) {\n        throw new Error('file not found');\n      }\n      // Subsequent methods are only passed the fileId, so make sure we have\n      // a way to get the file resources.\n      const file = { path, flags, accessHandle };\n      this.#mapIdToFile.set(fileId, file);\n\n      pOutFlags.setInt32(0, flags, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      console.error(e.message);\n      return VFS.SQLITE_CANTOPEN;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  jClose(fileId) {\n    const file = this.#mapIdToFile.get(fileId);\n    if (file) {\n      file.accessHandle.flush();\n      this.#mapIdToFile.delete(fileId);\n      if (file.flags & VFS.SQLITE_OPEN_DELETEONCLOSE) {\n        this.#deletePath(file.path);\n      }\n    }\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  jRead(fileId, pData, iOffset) {\n    const file = this.#mapIdToFile.get(fileId);\n    const nBytes = file.accessHandle.read(\n      pData.subarray(),\n      { at: HEADER_OFFSET_DATA + iOffset });\n    if (nBytes < pData.byteLength) {\n      pData.fill(0, nBytes, pData.byteLength);\n      return VFS.SQLITE_IOERR_SHORT_READ;\n    }\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  jWrite(fileId, pData, iOffset) {\n    const file = this.#mapIdToFile.get(fileId);\n    const nBytes = file.accessHandle.write(\n      pData.subarray(),\n      { at: HEADER_OFFSET_DATA + iOffset });\n    return nBytes === pData.byteLength ? VFS.SQLITE_OK : VFS.SQLITE_IOERR;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} iSize \n   * @returns {number}\n   */\n  jTruncate(fileId, iSize) {\n    const file = this.#mapIdToFile.get(fileId);\n    file.accessHandle.truncate(HEADER_OFFSET_DATA + iSize);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  jSync(fileId, flags) {\n    const file = this.#mapIdToFile.get(fileId);\n    file.accessHandle.flush();\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pSize64 \n   * @returns {number}\n   */\n  jFileSize(fileId, pSize64) {\n    const file = this.#mapIdToFile.get(fileId);\n    const size = file.accessHandle.getSize() - HEADER_OFFSET_DATA;\n    pSize64.setBigInt64(0, BigInt(size), true);\n    return VFS.SQLITE_OK;\n  }\n\n  jSectorSize(fileId) {\n    return SECTOR_SIZE;\n  }\n\n  jDeviceCharacteristics(fileId) {\n    return VFS.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  jAccess(zName, flags, pResOut) {\n    const path = this.#getPath(zName);\n    pResOut.setInt32(0, this.#mapPathToAccessHandle.has(path) ? 1 : 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} syncDir \n   * @returns {number}\n   */\n  jDelete(zName, syncDir) {\n    const path = this.#getPath(zName);\n    this.#deletePath(path);\n    return VFS.SQLITE_OK;\n  }\n\n  async close() {\n    await this.#releaseAccessHandles();\n  }\n\n  async isReady() {\n    if (!this.#directoryHandle) {\n      // All files are stored in a single directory.\n      let handle = await navigator.storage.getDirectory();\n      for (const d of this.#directoryPath.split('/')) {\n        if (d) {\n          handle = await handle.getDirectoryHandle(d, { create: true });\n        }\n      }\n      this.#directoryHandle = handle;\n\n      await this.#acquireAccessHandles();\n      if (this.getCapacity() === 0) {\n        await this.addCapacity(DEFAULT_CAPACITY);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the number of SQLite files in the file system.\n   * @returns {number}\n   */\n  getSize() {\n    return this.#mapPathToAccessHandle.size;\n  }\n\n  /**\n   * Returns the maximum number of SQLite files the file system can hold.\n   * @returns {number}\n   */\n  getCapacity() {\n    return this.#mapAccessHandleToName.size;\n  }\n\n  /**\n   * Increase the capacity of the file system by n.\n   * @param {number} n \n   * @returns {Promise<number>} \n   */\n  async addCapacity(n) {\n    for (let i = 0; i < n; ++i) {\n      const name = Math.random().toString(36).replace('0.', '');\n      const handle = await this.#directoryHandle.getFileHandle(name, { create: true });\n      const accessHandle = await handle.createSyncAccessHandle();\n      this.#mapAccessHandleToName.set(accessHandle, name);\n\n      this.#setAssociatedPath(accessHandle, '', 0);\n    }\n    return n;\n  }\n\n  /**\n   * Decrease the capacity of the file system by n. The capacity cannot be\n   * decreased to fewer than the current number of SQLite files in the\n   * file system.\n   * @param {number} n \n   * @returns {Promise<number>}\n   */\n  async removeCapacity(n) {\n    let nRemoved = 0;\n    for (const accessHandle of Array.from(this.#availableAccessHandles)) {\n      if (nRemoved == n || this.getSize() === this.getCapacity()) return nRemoved;\n\n      const name = this.#mapAccessHandleToName.get(accessHandle);\n      await accessHandle.close();\n      await this.#directoryHandle.removeEntry(name);\n      this.#mapAccessHandleToName.delete(accessHandle);\n      this.#availableAccessHandles.delete(accessHandle);\n      ++nRemoved;\n    }\n    return nRemoved;\n  }\n\n  async #acquireAccessHandles() {\n    // Enumerate all the files in the directory.\n    const files = [];\n    for await (const [name, handle] of this.#directoryHandle) {\n      if (handle.kind === 'file') {\n        files.push([name, handle]);\n      }\n    }\n\n    // Open access handles in parallel, separating associated and unassociated.\n    await Promise.all(files.map(async ([name, handle]) => {\n      const accessHandle = await handle.createSyncAccessHandle();\n      this.#mapAccessHandleToName.set(accessHandle, name);\n      const path = this.#getAssociatedPath(accessHandle);\n      if (path) {\n        this.#mapPathToAccessHandle.set(path, accessHandle);\n      } else {\n        this.#availableAccessHandles.add(accessHandle);\n      }\n    }));\n  }\n\n  #releaseAccessHandles() {\n    for (const accessHandle of this.#mapAccessHandleToName.keys()) {\n      accessHandle.close();\n    }\n    this.#mapAccessHandleToName.clear();\n    this.#mapPathToAccessHandle.clear();\n    this.#availableAccessHandles.clear();\n  }\n\n  /**\n   * Read and return the associated path from an OPFS file header.\n   * Empty string is returned for an unassociated OPFS file.\n   * @param accessHandle FileSystemSyncAccessHandle\n   * @returns {string} path or empty string\n   */\n  #getAssociatedPath(accessHandle) {\n    // Read the path and digest of the path from the file.\n    const corpus = new Uint8Array(HEADER_CORPUS_SIZE);\n    accessHandle.read(corpus, { at: 0 })\n\n    // Delete files not expected to be present.\n    const dataView = new DataView(corpus.buffer, corpus.byteOffset);\n    const flags = dataView.getUint32(HEADER_OFFSET_FLAGS);\n    if (corpus[0] &&\n        ((flags & VFS.SQLITE_OPEN_DELETEONCLOSE) ||\n         (flags & PERSISTENT_FILE_TYPES) === 0)) {\n      console.warn(`Remove file with unexpected flags ${flags.toString(16)}`);\n      this.#setAssociatedPath(accessHandle, '', 0);\n      return '';\n    }\n\n    const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);\n    accessHandle.read(fileDigest, { at: HEADER_OFFSET_DIGEST });\n\n    // Verify the digest.\n    const computedDigest = this.#computeDigest(corpus);\n    if (fileDigest.every((value, i) => value === computedDigest[i])) {\n      // Good digest. Decode the null-terminated path string.\n      const pathBytes = corpus.findIndex(value => value === 0);\n      if (pathBytes === 0) {\n        // Ensure that unassociated files are empty. Unassociated files are\n        // truncated in #setAssociatedPath after the header is written. If\n        // an interruption occurs right before the truncation then garbage\n        // may remain in the file.\n        accessHandle.truncate(HEADER_OFFSET_DATA);\n      }\n      return new TextDecoder().decode(corpus.subarray(0, pathBytes));\n    } else {\n      // Bad digest. Repair this header.\n      console.warn('Disassociating file with bad digest.');\n      this.#setAssociatedPath(accessHandle, '', 0);\n      return '';\n    }\n  }\n\n  /**\n   * Set the path on an OPFS file header.\n   * @param accessHandle FileSystemSyncAccessHandle\n   * @param {string} path\n   * @param {number} flags\n   */\n  #setAssociatedPath(accessHandle, path, flags) {\n    // Convert the path string to UTF-8.\n    const corpus = new Uint8Array(HEADER_CORPUS_SIZE);\n    const encodedResult = new TextEncoder().encodeInto(path, corpus);\n    if (encodedResult.written >= HEADER_MAX_PATH_SIZE) {\n      throw new Error('path too long');\n    }\n\n    // Add the creation flags.\n    const dataView = new DataView(corpus.buffer, corpus.byteOffset);\n    dataView.setUint32(HEADER_OFFSET_FLAGS, flags);\n\n    // Write the OPFS file header, including the digest.\n    const digest = this.#computeDigest(corpus);\n    accessHandle.write(corpus, { at: 0 });\n    accessHandle.write(digest, { at: HEADER_OFFSET_DIGEST });\n    accessHandle.flush();\n\n    if (path) {\n      this.#mapPathToAccessHandle.set(path, accessHandle);\n      this.#availableAccessHandles.delete(accessHandle);\n    } else {\n      // This OPFS file doesn't represent any SQLite file so it doesn't\n      // need to keep any data.\n      accessHandle.truncate(HEADER_OFFSET_DATA);\n      this.#availableAccessHandles.add(accessHandle);\n    }\n  }\n\n  /**\n   * We need a synchronous digest function so can't use WebCrypto.\n   * Adapted from https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\n   * @param {Uint8Array} corpus \n   * @returns {ArrayBuffer} 64-bit digest\n   */\n  #computeDigest(corpus) {\n    if (!corpus[0]) {\n      // Optimization for deleted file.\n      return new Uint32Array([0xfecc5f80, 0xaccec037]);\n    }\n\n    let h1 = 0xdeadbeef;\n    let h2 = 0x41c6ce57;\n    \n    for (const value of corpus) {\n      h1 = Math.imul(h1 ^ value, 2654435761);\n      h2 = Math.imul(h2 ^ value, 1597334677);\n    }\n    \n    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n    \n    return new Uint32Array([h1 >>> 0, h2 >>> 0]);\n  };\n  \n  /**\n   * Convert a bare filename, path, or URL to a UNIX-style path.\n   * @param {string|URL} nameOrURL\n   * @returns {string} path\n   */\n  #getPath(nameOrURL) {\n    const url = typeof nameOrURL === 'string' ?\n      new URL(nameOrURL, 'file://localhost/') :\n      nameOrURL;\n    return url.pathname;\n  }\n\n  /**\n   * Remove the association between a path and an OPFS file.\n   * @param {string} path \n   */\n  #deletePath(path) {\n    const accessHandle = this.#mapPathToAccessHandle.get(path);\n    if (accessHandle) {\n      // Un-associate the SQLite path from the OPFS file.\n      this.#mapPathToAccessHandle.delete(path);\n      this.#setAssociatedPath(accessHandle, '', 0);\n    }\n  }\n}"],"names":[],"sourceRoot":""}
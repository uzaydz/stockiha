import { supabase } from '@/lib/supabase';
import { Order, OrderItem, OrderStatus } from '../../types';
import { v4 as uuidv4 } from 'uuid';
import { ensureCustomerExists } from '@/lib/fallback_customer';
import { queryClient } from '@/lib/config/queryClient';

// Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ÙŠØ© Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨ÙŠØ¹
export const createPOSOrder = async (
  order: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>, 
  currentOrganizationId: string | undefined
): Promise<Order> => {
  try {
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ organization_id
    if (!currentOrganizationId) {
      throw new Error('Organization ID is required but was not provided');
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ¥Ù†Ø´Ø§Ø¦Ù‡ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
    const customerId = await ensureCustomerExists(order.customerId, currentOrganizationId);
    
    // ØªÙˆÙ„ÙŠØ¯ slug ÙØ±ÙŠØ¯ Ù„Ù„Ø·Ù„Ø¨ÙŠØ© (Ø¨Ø£Ø­Ø±Ù ØµØºÙŠØ±Ø© Ù„ØªÙˆØ§ÙÙ‚ Ø§Ù„Ù‚ÙŠØ¯)
    const orderSlug = `pos-${new Date().getTime()}-${Math.floor(Math.random() * 1000)}`;
    
    // ØªØ­Ø¶ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨ÙŠØ©
    const orderData = {
      customer_id: customerId,
      organization_id: currentOrganizationId,
      slug: orderSlug,
      status: order.status || 'completed',
      payment_status: order.paymentStatus || 'paid',
      payment_method: order.paymentMethod || 'cash',
      subtotal: order.subtotal || 0,
      tax: order.tax || 0,
      discount: order.discount || 0,
      total: order.total || 0,
      notes: order.notes || '',
      is_online: false,
      employee_id: order.employeeId || null,
      // Ø­Ù‚ÙˆÙ„ Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨ÙŠØ¹
      pos_order_type: 'pos',
      amount_paid: order.partialPayment?.amountPaid || order.total || 0,
      remaining_amount: order.partialPayment?.remainingAmount || 0,
      consider_remaining_as_partial: order.considerRemainingAsPartial || false,
      completed_at: order.status === 'completed' ? new Date().toISOString() : null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨ Ù…Ø¨Ø§Ø´Ø±Ø©
    const { data: insertedOrder, error: orderError } = await supabase
      .from('orders')
      .insert(orderData)
      .select()
      .single();
      
    if (orderError) {
      throw new Error(`Error creating order: ${orderError.message}`);
    }
    
    const newOrderId = insertedOrder.id;

    // Ø¥Ø¶Ø§ÙØ© Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„ ÙˆØ¢Ù…Ù†
    if (order.items && order.items.length > 0) {
      try {
        
        // Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø­Ø¯ ØªÙ„Ùˆ Ø§Ù„Ø¢Ø®Ø± Ø¨Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙÙ‚Ø·
        for (let index = 0; index < order.items.length; index++) {
          const item = order.items[index];
          
          const itemData = {
            order_id: newOrderId,
            product_id: item.productId,
            product_name: item.productName || item.name || 'Ù…Ù†ØªØ¬',
            name: item.productName || item.name || 'Ù…Ù†ØªØ¬',
            quantity: item.quantity,
            unit_price: item.unitPrice,
            total_price: item.unitPrice * item.quantity,
            is_digital: item.isDigital || false,
            organization_id: currentOrganizationId, // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡ Ù„ÙŠØ³ null
            slug: `item-${Date.now()}-${index}`
          };

          const { error: itemError } = await supabase
            .from('order_items')
            .insert(itemData);

          if (itemError) {
            // Ù†Ø³ØªÙ…Ø± ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø­ØªÙ‰ Ù„Ùˆ ÙØ´Ù„ Ø£Ø­Ø¯Ù‡Ø§
          }
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        await updateInventoryForOrder(order.items);
      } catch (error) {
      }
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø®Ø¯Ù…Ø§Øª
    if (order.services && order.services.length > 0) {
      await addServiceBookings(order.services, newOrderId, customerId, order.employeeId, currentOrganizationId);
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù…Ù„Ø© Ù…Ø§Ù„ÙŠØ©
    try {
      await addOrderTransaction(newOrderId, order, currentOrganizationId);
    } catch (error) {
    }
    
    // =================================================================
    // ğŸš€ CACHE INVALIDATION
    // =================================================================
    try {
      if (currentOrganizationId) {
        // Invalidate orders, products, and dashboard data
        await queryClient.invalidateQueries({ queryKey: ['pos-orders', currentOrganizationId] });
        await queryClient.invalidateQueries({ queryKey: ['pos-orders-stats', currentOrganizationId] });
        await queryClient.invalidateQueries({ queryKey: ['products', currentOrganizationId] });
        await queryClient.invalidateQueries({ queryKey: ['dashboard-data', currentOrganizationId] });
      }
    } catch (cacheError) {
    }
    
    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ù…Ø¶Ø§Ù Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø©
    return {
      ...order,
      id: newOrderId,
      customer_order_number: insertedOrder.customer_order_number,
      createdAt: new Date(insertedOrder.created_at),
      updatedAt: new Date(insertedOrder.updated_at),
      slug: insertedOrder.slug
    };
  } catch (error) {
    throw error;
  }
};

// Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
async function updateInventoryForOrder(items: OrderItem[]) {
  for (const item of items) {
    try {
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¢Ù…Ù†Ø© Ù„ØªØ­Ø¯ÙŠØ« Ù…Ø®Ø²ÙˆÙ† Ø§Ù„Ù…Ù†ØªØ¬
      await supabase.rpc('update_product_stock_safe', {
        p_product_id: item.productId,
        p_quantity_sold: item.quantity
      });
    } catch (error) {
    }
  }
}

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø®Ø¯Ù…Ø§Øª
async function addServiceBookings(
  services: any[], 
  orderId: string, 
  defaultCustomerId: string, 
  employeeId: string | undefined,
  organizationId: string | undefined
) {
  for (const service of services) {
    try {
      const serviceBookingData = {
        id: service.id || uuidv4(),
        order_id: orderId,
        service_id: service.serviceId,
        service_name: service.serviceName,
        price: service.price,
        scheduled_date: service.scheduledDate,
        notes: service.notes || "",
        customer_name: service.customer_name || "Ø²Ø§Ø¦Ø±",
        customer_id: service.customerId || defaultCustomerId || null,
        assigned_to: service.assignedTo || employeeId || null,
        status: service.status || 'pending',
        public_tracking_code: service.public_tracking_code || `SRV-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
        slug: `booking-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
        organization_id: organizationId,
        created_at: new Date().toISOString()
      };

      const { error: serviceBookingError } = await supabase
        .from('service_bookings')
        .insert(serviceBookingData);
        
      if (serviceBookingError) {
      }
    } catch (error) {
    }
  }
}

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù…Ù„Ø© Ù…Ø§Ù„ÙŠØ©
async function addOrderTransaction(
  orderId: string, 
  order: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>,
  organizationId: string | undefined
) {
  try {
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ organization_id
    if (!organizationId) {
      throw new Error('Organization ID is required for transaction but was not provided');
    }
    
    // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙ‚Ø·
    const transactionData = {
      order_id: orderId,
      amount: order.paymentStatus === 'paid' ? order.total : (order.partialPayment?.amountPaid || 0),
      type: 'sale',
      payment_method: order.paymentMethod || 'cash',
      description: order.paymentStatus === 'paid' 
        ? `Payment for POS order` 
        : `Partial payment for POS order`,
      employee_id: order.employeeId || null,
      organization_id: organizationId
    };

    const { error } = await supabase
      .from('transactions')
      .insert(transactionData);
      
    if (error) {
      throw error;
    }
  } catch (error) {
    throw error;
  }
}

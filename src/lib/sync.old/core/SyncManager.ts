/**
 * âš¡ Unified SyncManager - Ù…Ø¯ÙŠØ± Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…ÙˆØ­Ø¯
 *
 * Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
 * - Ø£Ø³Ù…Ø§Ø¡ Ù…ÙˆØ­Ø¯Ø© 100% Ù…Ø¹ Supabase (Ù„Ø§ TABLE_MAP)
 * - ÙÙ„ØªØ±Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø­Ù„ÙŠØ© (ØªØ¨Ø¯Ø£ Ø¨Ù€ _)
 * - Ù…Ø²Ø§Ù…Ù†Ø© Ù…ØªÙˆØ§Ø²ÙŠØ© Ù„Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø³ØªÙ‚Ù„Ø©
 * - Ø¬Ø¯ÙˆÙ„Ø© Ø°ÙƒÙŠØ© Ø­Ø³Ø¨ Ù†Ø´Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
 * - Circuit Breaker Ù„Ù„Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„ÙØ´Ù„ Ø§Ù„Ù…ØªÙƒØ±Ø±
 * - Ø£Ø­Ø¯Ø§Ø« Ù…ÙØµÙ„Ø© Ù„Ù„Ù€ UI
 *
 * Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:
 * - LocalUser, LocalOrder, LocalProduct, etc.
 */

import { PullEngine } from './PullEngine';
import { PushEngine } from './PushEngine';
import {
    SYNCED_TABLES,
    INDEPENDENT_TABLES,
    DEPENDENT_TABLES,
    SYNC_TIMING,
    BATCH_CONFIG,
} from '../config';
import { outboxManager } from '../queue/OutboxManager';
import { sqliteWriteQueue } from './SQLiteWriteQueue';
import { databaseCoordinator } from './DatabaseCoordinator';
import type {
    SyncStats,
    SyncResult,
    PullResult,
    PushResult,
} from '@/lib/types';

// ============================================
// ğŸ“Š Types - Ø§Ù„Ø£Ù†ÙˆØ§Ø¹
// ============================================

interface SyncManagerStats {
    totalSyncs: number;
    lastSyncTime: string | null;
    lastSyncDuration: number;
    lastSyncResults: Record<string, PullResult>;
    pendingCount: number;
    errorCount: number;
}

interface SyncCycleResult {
    success: boolean;
    duration: number;
    results: Record<string, PullResult>;
    totals: {
        processed: number;
        skipped: number;
        errors: number;
    };
}

// ============================================
// âš¡ SyncManager Class
// ============================================

class SyncManager {
    private static instance: SyncManager;

    private organizationId: string | null = null;
    private pullEngine: PullEngine | null = null;
    private pushEngine: PushEngine | null = null;

    private isSyncing = false;
    private isInitialized = false;

    // Smart Scheduler
    private syncTimer: ReturnType<typeof setTimeout> | null = null;
    private lastActivityTime: number = Date.now();
    private activityListeners: (() => void)[] = [];

    // Statistics
    private stats: SyncManagerStats = {
        totalSyncs: 0,
        lastSyncTime: null,
        lastSyncDuration: 0,
        lastSyncResults: {},
        pendingCount: 0,
        errorCount: 0,
    };

    private constructor() { }

    /**
     * âš¡ Get singleton instance
     */
    static getInstance(): SyncManager {
        if (!SyncManager.instance) {
            SyncManager.instance = new SyncManager();
        }
        return SyncManager.instance;
    }

    // ============================================
    // ğŸš€ Lifecycle Methods
    // ============================================

    /**
     * âš¡ Initialize and start the SyncManager
     */
    async start(organizationId: string): Promise<void> {
        // Prevent double initialization
        if (this.organizationId === organizationId && this.isInitialized) {
            console.log('[SyncManager] âš ï¸ Already initialized for this organization');
            return;
        }

        console.log(`[SyncManager] ğŸš€ Starting for Organization: ${organizationId}`);
        this.organizationId = organizationId;

        try {
            // âš¡ CRITICAL FIX: Wait for database initialization before proceeding
            console.log('[SyncManager] â³ Waiting for database initialization...');
            const { dbInitManager } = await import('@/lib/db/DatabaseInitializationManager');

            if (!dbInitManager.isInitialized(organizationId)) {
                await dbInitManager.initialize(organizationId, { timeout: 15000 });
                console.log('[SyncManager] âœ… Database initialized successfully');
            } else {
                console.log('[SyncManager] âœ… Database already initialized');
            }

            // Initialize Engines
            this.pullEngine = new PullEngine(organizationId);
            this.pushEngine = new PushEngine();

            // Initialize database tables
            await outboxManager.initialize();
            await this.pullEngine.init();

            // âš¡ One-time fix: Reset sync state for order_items (was incorrectly in NO_ORG_ID_TABLES)
            await this.applyOneMigrationFix();

            // Cleanup stuck operations
            await this.cleanupStuckOperations();

            // Start Push Engine (background)
            this.pushEngine.start(organizationId);

            // Setup Activity Tracking
            this.setupActivityTracking();

            // Perform Initial Full Sync
            await this.syncAll();

            // Start Smart Scheduler
            this.scheduleNextSync();

            // Ensure data integrity
            await this.ensureDataIntegrity();

            // âš¡ CRITICAL FIX: Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ø­Ø¯Ø« Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø¨Ø¹Ø¯ POS operation
            // Ù‡Ø°Ø§ ÙŠØ¶Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ØªØ¨Ø¯Ø£ ÙÙˆØ±Ø§Ù‹ Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ÙŠØ© POS
            if (typeof window !== 'undefined') {
                window.addEventListener('sync-resumed-after-pos', () => {
                    console.log('[SyncManager] ğŸ”„ Sync resumed after POS operation - triggering immediate sync...');
                    // âš¡ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ÙÙˆØ±Ø§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ POS operation
                    setTimeout(() => {
                        if (!databaseCoordinator.isSyncPaused() && !this.isSyncing) {
                            this.syncAll().catch(error => {
                                console.error('[SyncManager] Error in post-POS sync:', error);
                            });
                        }
                    }, 500); // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† POS operation Ø§Ù†ØªÙ‡Ù‰ ØªÙ…Ø§Ù…Ø§Ù‹
                });
            }

            this.isInitialized = true;
            console.log('[SyncManager] âœ… Initialization complete');

            // Dispatch ready event
            this.dispatchEvent('sync-manager-ready', {
                organizationId,
                timestamp: new Date().toISOString(),
            });

        } catch (error) {
            console.error('[SyncManager] âŒ Initialization failed:', error);
            this.dispatchEvent('sync-manager-error', { error: String(error) });
            throw error;
        }
    }

    /**
     * âš¡ Stop all sync operations
     */
    stop(): void {
        // Stop timer
        if (this.syncTimer) {
            clearTimeout(this.syncTimer);
            this.syncTimer = null;
        }

        // Cleanup activity listeners
        this.cleanupActivityListeners();

        // Stop engines
        if (this.pushEngine) {
            this.pushEngine.stop();
        }

        this.organizationId = null;
        this.pullEngine = null;
        this.pushEngine = null;
        this.isInitialized = false;

        console.log('[SyncManager] â¹ï¸ Stopped');
        this.dispatchEvent('sync-manager-stopped', {});
    }

    // ============================================
    // ğŸ”„ Sync Methods
    // ============================================

    /**
     * âš¡ Perform a full sync cycle
     */
    async syncAll(): Promise<SyncCycleResult> {
        if (this.isSyncing || !this.pullEngine) {
            return {
                success: false,
                duration: 0,
                results: {},
                totals: { processed: 0, skipped: 0, errors: 0 },
            };
        }

        this.isSyncing = true;
        const startTime = Date.now();
        const results: Record<string, PullResult> = {};
        let hasErrors = false;

        this.dispatchEvent('sync-started', {
            timestamp: new Date().toISOString(),
        });

        console.log('[SyncManager] ğŸ”„ Starting Full Sync Cycle...');

        try {
            // âš¡ CRITICAL: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø¨ÙˆØ§Ø³Ø·Ø© DatabaseCoordinator
            // Ù‡Ø°Ø§ ÙŠÙ…Ù†Ø¹ Ø§Ù„ØªØ¹Ø§Ø±Ø¶ Ù…Ø¹ Ø¹Ù…Ù„ÙŠØ§Øª POS Ø§Ù„Ø­Ø±Ø¬Ø©
            if (databaseCoordinator.isSyncPaused()) {
                console.log('[SyncManager] â¸ï¸ Sync paused by DatabaseCoordinator, skipping cycle...');
                return {
                    success: true,
                    duration: 0,
                    results,
                    totals: { processed: 0, skipped: 0, errors: 0 },
                };
            }

            // 1. Push first (send local changes)
            if (this.pushEngine) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù‚Ø¨Ù„ Push
                if (databaseCoordinator.isSyncPaused()) {
                    console.log('[SyncManager] â¸ï¸ Sync paused before push, skipping...');
                    return { success: true, duration: 0, results, totals: { processed: 0, skipped: 0, errors: 0 } };
                }
                console.log('[SyncManager] â¬†ï¸ Pushing local changes...');
                const pushResult = await this.pushEngine.processBatch();
                if (pushResult.failedCount > 0) {
                    console.warn(`[SyncManager] âš ï¸ ${pushResult.failedCount} push failures`);
                }
            }

            // 2. Clear pending cache
            this.pullEngine.clearCache();

            // âš¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù‚Ø¨Ù„ Pull
            if (databaseCoordinator.isSyncPaused()) {
                console.log('[SyncManager] â¸ï¸ Sync paused before pull, skipping...');
                return { success: true, duration: Date.now() - startTime, results, totals: { processed: 0, skipped: 0, errors: 0 } };
            }

            // 3. Pull Independent Tables (parallel)
            console.log('[SyncManager] â¬‡ï¸ Pulling independent tables in parallel...');
            const independentTables = (INDEPENDENT_TABLES as readonly string[]).filter(
                (t) => (SYNCED_TABLES as readonly string[]).includes(t)
            );

            const parallelResults = await this.pullEngine.pullTablesParallel(independentTables);
            parallelResults.forEach((result, table) => {
                results[table] = result;
                if (result.errors > 0) hasErrors = true;
            });

            // 4. Pull Dependent Tables (sequential)
            console.log('[SyncManager] â¬‡ï¸ Pulling dependent tables sequentially...');
            const dependentTables = (DEPENDENT_TABLES as readonly string[]).filter(
                (t) => (SYNCED_TABLES as readonly string[]).includes(t)
            );

            for (const table of dependentTables) {
                const result = await this.pullEngine.pullTable(table);
                results[table] = result;
                if (result.errors > 0) hasErrors = true;
            }

            // 5. Pull remaining tables
            const processedTables = new Set([...independentTables, ...dependentTables]);
            const remainingTables = (SYNCED_TABLES as readonly string[]).filter(
                (t) => !processedTables.has(t)
            );

            for (const table of remainingTables) {
                const result = await this.pullEngine.pullTable(table);
                results[table] = result;
                if (result.errors > 0) hasErrors = true;
            }

            const duration = Date.now() - startTime;

            // Update statistics
            const totals = this.calculateTotals(results);
            this.updateStats(duration, results, totals);

            console.log(
                `[SyncManager] âœ… Sync Complete in ${duration}ms - ` +
                `${totals.processed} processed, ${totals.skipped} skipped, ${totals.errors} errors`
            );

            this.dispatchEvent('sync-completed', {
                timestamp: new Date().toISOString(),
                duration,
                totals,
                results,
            });

            return { success: !hasErrors, duration, results, totals };

        } catch (error) {
            const duration = Date.now() - startTime;
            console.error('[SyncManager] âŒ Full Sync Cycle Failed:', error);

            this.dispatchEvent('sync-error', {
                error: String(error),
                duration,
            });

            return {
                success: false,
                duration,
                results,
                totals: { processed: 0, skipped: 0, errors: 1 },
            };
        } finally {
            this.isSyncing = false;
        }
    }

    /**
     * âš¡ Sync a specific table
     */
    async syncTable(tableName: string): Promise<PullResult | null> {
        if (!this.pullEngine) return null;

        // Push first
        if (this.pushEngine) {
            await this.pushEngine.processBatch();
        }

        return await this.pullEngine.pullTable(tableName);
    }

    /**
     * âš¡ Force immediate sync (bypasses scheduler)
     */
    async forceSync(): Promise<SyncCycleResult> {
        // Cancel current timer
        if (this.syncTimer) {
            clearTimeout(this.syncTimer);
        }

        const result = await this.syncAll();

        // Reschedule
        this.scheduleNextSync();

        return result;
    }

    // ============================================
    // â±ï¸ Smart Scheduling
    // ============================================

    /**
     * âš¡ Setup activity tracking for smart scheduling
     */
    private setupActivityTracking(): void {
        this.cleanupActivityListeners();

        const updateActivity = () => {
            this.lastActivityTime = Date.now();
        };

        const events = ['click', 'keypress', 'touchstart', 'mousemove', 'scroll'];
        events.forEach((event) => {
            const listener = () => updateActivity();
            window.addEventListener(event, listener, { passive: true });
            this.activityListeners.push(() => window.removeEventListener(event, listener));
        });
    }

    /**
     * âš¡ Cleanup activity listeners
     */
    private cleanupActivityListeners(): void {
        this.activityListeners.forEach((cleanup) => cleanup());
        this.activityListeners = [];
    }

    /**
     * âš¡ Calculate next sync interval based on activity
     */
    private calculateNextSyncInterval(): number {
        const idleTime = Date.now() - this.lastActivityTime;

        if (idleTime < SYNC_TIMING.IDLE_THRESHOLD) {
            return SYNC_TIMING.ACTIVE_INTERVAL;
        } else if (idleTime < SYNC_TIMING.INACTIVE_THRESHOLD) {
            return SYNC_TIMING.IDLE_INTERVAL;
        } else {
            return SYNC_TIMING.INACTIVE_INTERVAL;
        }
    }

    /**
     * âš¡ Schedule next sync
     */
    private scheduleNextSync(): void {
        if (this.syncTimer) {
            clearTimeout(this.syncTimer);
        }

        const interval = this.calculateNextSyncInterval();
        const intervalMinutes = Math.round(interval / 60000);

        console.log(`[SyncManager] â±ï¸ Next sync in ${intervalMinutes} minutes`);

        this.syncTimer = setTimeout(async () => {
            await this.syncAll();
            this.scheduleNextSync();
        }, interval);
    }

    // ============================================
    // ğŸ› ï¸ Utility Methods
    // ============================================

    /**
     * âš¡ One-time migration fix for order_items sync issue
     * order_items was incorrectly in NO_ORG_ID_TABLES, causing it to not filter by organization_id
     * This fix clears all order_items and forces a full re-sync from epoch
     */
    private async applyOneMigrationFix(): Promise<void> {
        // v3: Clear order_items and force complete re-sync
        const MIGRATION_KEY = '_migration_order_items_full_resync_v3';

        try {
            // Check if migration was already applied (using sync_state table as storage)
            const migrationApplied = await sqliteWriteQueue.read<{ table_name: string }[]>(
                `SELECT table_name FROM sync_state WHERE table_name = ?`,
                [MIGRATION_KEY]
            );

            if (migrationApplied.length > 0) {
                return; // Already applied
            }

            console.log('[SyncManager] ğŸ”§ Applying order_items full re-sync fix (v3)...');

            // 1. Delete all existing order_items (they were pulled without org filter)
            await sqliteWriteQueue.write(`DELETE FROM order_items WHERE 1=1`);
            console.log('[SyncManager] ğŸ—‘ï¸ Cleared order_items table');

            // 2. Reset sync state for order_items to epoch (force full re-sync)
            if (this.pullEngine) {
                await this.pullEngine.resetSyncState(['order_items']);
                console.log('[SyncManager] ğŸ”„ Reset order_items sync state to epoch');
            }

            // Mark migration as applied
            await sqliteWriteQueue.write(
                `INSERT OR REPLACE INTO sync_state (table_name, last_synced_at, last_sync_status) VALUES (?, ?, ?)`,
                [MIGRATION_KEY, new Date().toISOString(), 'applied']
            );

            console.log('[SyncManager] âœ… order_items full re-sync fix applied (v3)');
        } catch (error) {
            console.warn('[SyncManager] âš ï¸ Migration fix failed (non-critical):', error);
        }
    }

    /**
     * âš¡ Cleanup stuck operations on startup
     */
    private async cleanupStuckOperations(): Promise<void> {
        try {
            // Requeue stuck 'sending' operations
            const requeuedStuck = await outboxManager.requeueStuck();
            if (requeuedStuck > 0) {
                console.log(`[SyncManager] ğŸ”„ Requeued ${requeuedStuck} stuck 'sending' operations`);
            }

            // Auto-clean payloads
            const cleanupResult = await outboxManager.autoCleanAllPayloads();
            if (cleanupResult.cleaned > 0 || cleanupResult.removed > 0 || cleanupResult.converted > 0) {
                console.log(
                    `[SyncManager] ğŸ§¹ Outbox cleanup: ` +
                    `${cleanupResult.cleaned} cleaned, ` +
                    `${cleanupResult.converted} camelCaseâ†’snake_case, ` +
                    `${cleanupResult.removed} removed`
                );
            }

            // âš¡ Remove corrupted entries that cannot be fixed (orphan order_items, etc.)
            const corruptedRemoved = await outboxManager.removeCorruptedEntries();
            if (corruptedRemoved > 0) {
                console.log(`[SyncManager] ğŸ—‘ï¸ Removed ${corruptedRemoved} corrupted outbox entries`);
            }

            // âš¡ Remove schema mismatch errors (PGRST204 - column doesn't exist)
            const schemaErrorsRemoved = await outboxManager.removeSchemaErrors();
            if (schemaErrorsRemoved > 0) {
                console.log(`[SyncManager] ğŸ—‘ï¸ Removed ${schemaErrorsRemoved} schema mismatch errors`);
            }

            // âš¡ Ù…Ù„Ø§Ø­Ø¸Ø©: fixSyncedOrdersStatus ØªÙ… Ù†Ù‚Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ensureDataIntegrity
            // Ù„Ø£Ù†Ù‡Ø§ ÙŠØ¬Ø¨ Ø£Ù† ØªØ¹Ù…Ù„ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ syncAll() ÙˆØ¥ÙØ±Ø§Øº Ø§Ù„Ù€ outbox

            // Backfill unsynced orders
            const backfillResult = await this.backfillUnsyncedOrders();
            if (backfillResult.ordersAdded > 0) {
                console.log(
                    `[SyncManager] ğŸ”„ Backfilled ` +
                    `${backfillResult.ordersAdded} orders, ` +
                    `${backfillResult.itemsAdded} items`
                );
            }
        } catch (error) {
            console.warn('[SyncManager] âš ï¸ Cleanup failed:', error);
        }
    }

    /**
     * âš¡ CRITICAL FIX: Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙŠ ØªÙ… Ù…Ø²Ø§Ù…Ù†ØªÙ‡Ø§ Ù„ÙƒÙ† synced Ù„Ù… ÙŠÙØ­Ø¯Ù‘Ø«
     * Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙŠ Ù„ÙŠØ³Øª ÙÙŠ outbox ÙˆÙ…ØªØ²Ø§Ù…Ù†Ø© ÙÙŠ Supabase ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† synced = 1
     * 
     * ÙŠØ­Ù„ Ù…Ø´ÙƒÙ„Ø©: Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙŠ ØªÙ… Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± (Pull) Ù„ÙƒÙ† synced Ù„Ù… ÙŠÙØ­Ø¯Ù‘Ø«
     */
    private async fixSyncedOrdersStatus(): Promise<void> {
        try {
            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙŠ synced = 0 Ø£Ùˆ NULL Ù„ÙƒÙ†Ù‡Ø§ Ù„ÙŠØ³Øª ÙÙŠ outbox
            // Ù‡Ø°Ù‡ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø¥Ù…Ø§ ØªÙ… Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± Ø£Ùˆ ØªÙ… Ù…Ø²Ø§Ù…Ù†ØªÙ‡Ø§ Ø¨Ù†Ø¬Ø§Ø­ Ù„ÙƒÙ† synced Ù„Ù… ÙŠÙØ­Ø¯Ù‘Ø«
            const ordersNotInOutbox = await sqliteWriteQueue.read<{ id: string }[]>(`
                SELECT o.id FROM orders o
                WHERE o.organization_id = ?
                AND (o.synced = 0 OR o.synced IS NULL)
                AND o.id NOT IN (
                    SELECT record_id FROM sync_outbox 
                    WHERE table_name = 'orders' AND status IN ('pending', 'sending', 'failed')
                )
                LIMIT 500
            `, [this.organizationId]);

            if (ordersNotInOutbox.length === 0) return;

            // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
            const ids = ordersNotInOutbox.map(o => o.id);
            const placeholders = ids.map(() => '?').join(',');

            await sqliteWriteQueue.write(`
                UPDATE orders SET synced = 1 WHERE id IN (${placeholders})
            `, ids);

            // âš¡ ØªØ­Ø¯ÙŠØ« order_items Ø£ÙŠØ¶Ø§Ù‹
            try {
                await sqliteWriteQueue.write(`
                    UPDATE order_items SET synced = 1 
                    WHERE order_id IN (${placeholders}) AND (synced = 0 OR synced IS NULL)
                `, ids);
            } catch (err) {
                console.warn('[SyncManager] âš ï¸ Could not update order_items sync status:', err);
            }

            console.log(`[SyncManager] âœ… Fixed ${ids.length} orders sync status (were synced but synced=0)`);
        } catch (error) {
            console.warn('[SyncManager] âš ï¸ Failed to fix synced orders status:', error);
        }
    }

    /**
     * âš¡ Ensure data integrity
     */
    private async ensureDataIntegrity(): Promise<void> {
        try {
            console.log('[SyncManager] ğŸ›¡ï¸ Checking data integrity...');

            // âš¡ ÙØ­Øµ 0: Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø© Ø§Ù„ØªÙŠ Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« synced Ù„Ù‡Ø§
            // Ù‡Ø°Ø§ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¹Ù…Ù„ Ø¨Ø¹Ø¯ syncAll() ÙˆØ¥ÙØ±Ø§Øº Ø§Ù„Ù€ outbox
            // âš¡ CRITICAL FIX: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† 100 Ø¥Ù„Ù‰ 500 Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
            await this.fixSyncedOrdersStatus();

            // âš¡ ÙØ­Øµ 1: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø·Ù„Ø¨ÙŠØ§Øª - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙØ§Ø±ØºØ§Ù‹ØŒ Ù†ÙØ¹ÙŠØ¯ Ø§Ù„Ø³Ø­Ø¨
            await this.ensureOrdersExist();

            // Fix orders with missing payment_method
            // âœ… Ø§Ù„Ø¢Ù† Ù†Ø³ØªØ®Ø¯Ù… 'orders' Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† 'pos_orders' (Ø£Ø³Ù…Ø§Ø¡ Ù…ÙˆØ­Ø¯Ø©)
            const ordersWithMissingPayment = await sqliteWriteQueue.read<{ id: string }[]>(
                `SELECT id FROM orders WHERE payment_method IS NULL OR payment_method = '' LIMIT 10`
            );

            if (ordersWithMissingPayment.length > 0) {
                console.warn(
                    `[SyncManager] âš ï¸ Found ${ordersWithMissingPayment.length} orders with null payment_method`
                );

                // Get default from settings
                let defaultPaymentMethod = 'cash';
                try {
                    const settings = await sqliteWriteQueue.read<{ pos_default_payment_method: string }[]>(
                        `SELECT pos_default_payment_method FROM pos_settings WHERE organization_id = ? LIMIT 1`,
                        [this.organizationId]
                    );
                    if (settings.length > 0 && settings[0].pos_default_payment_method) {
                        defaultPaymentMethod = settings[0].pos_default_payment_method;
                    }
                } catch {
                    // Use fallback
                }

                await sqliteWriteQueue.write(
                    `UPDATE orders SET payment_method = ? WHERE payment_method IS NULL OR payment_method = ''`,
                    [defaultPaymentMethod]
                );

                console.log(
                    `[SyncManager] âœ… Fixed ${ordersWithMissingPayment.length} orders ` +
                    `with payment_method = '${defaultPaymentMethod}'`
                );
            }

        } catch (error) {
            console.error('[SyncManager] âŒ Data integrity check failed:', error);
        }
    }

    /**
     * âš¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø·Ù„Ø¨ÙŠØ§Øª - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙØ§Ø±ØºØ§Ù‹ Ù…Ø¹ ÙˆØ¬ÙˆØ¯ sync_stateØŒ Ù†ÙØ¹ÙŠØ¯ Ø§Ù„Ø³Ø­Ø¨ Ø§Ù„ÙƒØ§Ù…Ù„
     */
    private async ensureOrdersExist(): Promise<void> {
        if (!this.organizationId || !this.pullEngine) return;

        try {
            // ÙØ­Øµ Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø¨ÙŠØ§Øª ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ù„ÙŠ
            const countResult = await sqliteWriteQueue.read<{ count: number }[]>(
                `SELECT COUNT(*) as count FROM orders WHERE organization_id = ?`,
                [this.organizationId]
            );
            const localOrdersCount = countResult[0]?.count || 0;

            // ÙØ­Øµ sync_state Ù„Ù„Ø·Ù„Ø¨ÙŠØ§Øª
            const syncStateResult = await sqliteWriteQueue.read<{ last_synced_at: string }[]>(
                `SELECT last_synced_at FROM sync_state WHERE table_name = 'orders'`
            );
            const hasSyncState = syncStateResult.length > 0 && syncStateResult[0]?.last_synced_at;

            console.log(`[SyncManager] ğŸ“Š Orders integrity check: local=${localOrdersCount}, hasSyncState=${!!hasSyncState}`);

            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙØ§Ø±ØºØ§Ù‹ ÙˆÙ„ÙƒÙ† sync_state Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù‡Ù†Ø§Ùƒ Ù…Ø´ÙƒÙ„Ø© - Ù†ÙØ¹ÙŠØ¯ Ø§Ù„Ø³Ø­Ø¨
            if (localOrdersCount === 0 && hasSyncState) {
                console.warn('[SyncManager] âš ï¸ Orders table is empty but sync_state exists! Forcing full re-sync...');

                // Ø­Ø°Ù sync_state Ù„Ù„Ø·Ù„Ø¨ÙŠØ§Øª Ù„Ø¥Ø¬Ø¨Ø§Ø± Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø³Ø­Ø¨ Ø§Ù„ÙƒØ§Ù…Ù„
                await sqliteWriteQueue.write(
                    `DELETE FROM sync_state WHERE table_name IN ('orders', 'order_items')`
                );

                // Ø¥Ø¹Ø§Ø¯Ø© Ø³Ø­Ø¨ Ø§Ù„Ø·Ù„Ø¨ÙŠØ§Øª
                console.log('[SyncManager] ğŸ”„ Re-pulling orders from server...');
                const ordersResult = await this.pullEngine.pullTable('orders');
                console.log(`[SyncManager] âœ… Orders re-pull: ${ordersResult.processed} processed`);

                // Ø¥Ø¹Ø§Ø¯Ø© Ø³Ø­Ø¨ Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø·Ù„Ø¨ÙŠØ§Øª
                console.log('[SyncManager] ğŸ”„ Re-pulling order_items from server...');
                const itemsResult = await this.pullEngine.pullTable('order_items');
                console.log(`[SyncManager] âœ… Order items re-pull: ${itemsResult.processed} processed`);
            }

        } catch (error) {
            console.error('[SyncManager] âŒ ensureOrdersExist failed:', error);
        }
    }

    /**
     * âš¡ Backfill unsynced orders
     */
    async backfillUnsyncedOrders(): Promise<{
        ordersAdded: number;
        itemsAdded: number;
        errors: string[];
    }> {
        if (!this.organizationId) {
            return { ordersAdded: 0, itemsAdded: 0, errors: ['No organization ID set'] };
        }

        const result = { ordersAdded: 0, itemsAdded: 0, errors: [] as string[] };

        try {
            // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… 'orders' Ùˆ 'order_items' (Ø£Ø³Ù…Ø§Ø¡ Ù…ÙˆØ­Ø¯Ø©)
            // âš¡ v2: Ø§Ø³ØªØ®Ø¯Ø§Ù… 'synced' Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† '_synced' (Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ tauriSchema)
            const unsyncedOrders = await sqliteWriteQueue.read<Record<string, unknown>[]>(
                `SELECT * FROM orders
                WHERE organization_id = ?
                AND (synced = 0 OR synced IS NULL)
                ORDER BY created_at ASC
                LIMIT 50`,
                [this.organizationId]
            );

            for (const order of unsyncedOrders) {
                try {
                    const existsInOutbox = await sqliteWriteQueue.read<{ id: string }[]>(
                        `SELECT id FROM sync_outbox
                        WHERE table_name = 'orders'
                        AND record_id = ?
                        AND status != 'sent'`,
                        [order.id]
                    );

                    if (existsInOutbox.length === 0) {
                        // Fix missing payment_method
                        if (!order.payment_method) {
                            order.payment_method = 'cash';
                            await sqliteWriteQueue.write(
                                `UPDATE orders SET payment_method = 'cash' WHERE id = ?`,
                                [order.id]
                            );
                        }

                        await outboxManager.add({
                            tableName: 'orders',
                            operation: 'INSERT',
                            recordId: order.id as string,
                            payload: order,
                        });
                        result.ordersAdded++;

                        // Get order items
                        const orderItems = await sqliteWriteQueue.read<Record<string, unknown>[]>(
                            `SELECT * FROM order_items WHERE order_id = ?`,
                            [order.id]
                        );

                        for (const item of orderItems) {
                            const itemExistsInOutbox = await sqliteWriteQueue.read<{ id: string }[]>(
                                `SELECT id FROM sync_outbox
                                WHERE table_name = 'order_items'
                                AND record_id = ?
                                AND status != 'sent'`,
                                [item.id]
                            );

                            if (itemExistsInOutbox.length === 0) {
                                await outboxManager.add({
                                    tableName: 'order_items',
                                    operation: 'INSERT',
                                    recordId: item.id as string,
                                    payload: item,
                                });
                                result.itemsAdded++;
                            }
                        }
                    }
                } catch (orderError) {
                    result.errors.push(`Order ${order.id}: ${String(orderError)}`);
                }
            }

            // Trigger immediate push
            if (result.ordersAdded > 0 && this.pushEngine) {
                await this.pushEngine.processBatch();
            }

        } catch (error) {
            result.errors.push(String(error));
        }

        return result;
    }

    /**
     * âš¡ Calculate totals from results
     */
    private calculateTotals(results: Record<string, PullResult>): {
        processed: number;
        skipped: number;
        errors: number;
    } {
        return Object.values(results).reduce(
            (acc, r) => ({
                processed: acc.processed + r.processed,
                skipped: acc.skipped + r.skipped,
                errors: acc.errors + r.errors,
            }),
            { processed: 0, skipped: 0, errors: 0 }
        );
    }

    /**
     * âš¡ Update statistics
     */
    private updateStats(
        duration: number,
        results: Record<string, PullResult>,
        totals: { processed: number; skipped: number; errors: number }
    ): void {
        this.stats.totalSyncs++;
        this.stats.lastSyncTime = new Date().toISOString();
        this.stats.lastSyncDuration = duration;
        this.stats.lastSyncResults = results;
        this.stats.errorCount = totals.errors;
    }

    /**
     * âš¡ Dispatch custom event
     */
    private dispatchEvent(name: string, detail: Record<string, unknown>): void {
        if (typeof window !== 'undefined') {
            window.dispatchEvent(new CustomEvent(name, { detail }));
        }
    }

    // ============================================
    // ğŸ“Š Public Getters
    // ============================================

    /**
     * âš¡ Get sync statistics
     */
    getStats(): SyncManagerStats & { currentInterval: number; isActive: boolean } {
        return {
            ...this.stats,
            currentInterval: this.calculateNextSyncInterval(),
            isActive: Date.now() - this.lastActivityTime < SYNC_TIMING.IDLE_THRESHOLD,
        };
    }

    /**
     * âš¡ Check if sync is in progress
     */
    get syncing(): boolean {
        return this.isSyncing;
    }

    /**
     * âš¡ Check if initialized
     */
    get initialized(): boolean {
        return this.isInitialized;
    }

    /**
     * âš¡ Get organization ID
     */
    get orgId(): string | null {
        return this.organizationId;
    }

    /**
     * âš¡ Force full re-sync for specific tables
     * ÙŠØ­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© ÙˆÙŠØ³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ù…Ù† Supabase
     */
    async forceFullResync(tableNames: string[]): Promise<{ success: boolean; results: Record<string, PullResult> }> {
        if (!this.pullEngine || !this.organizationId) {
            console.error('[SyncManager] âŒ Not initialized');
            return { success: false, results: {} };
        }

        console.log(`[SyncManager] ğŸ”„ Force full re-sync for: ${tableNames.join(', ')}`);

        try {
            // 1. Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ù„Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
            for (const table of tableNames) {
                await sqliteWriteQueue.write(
                    `DELETE FROM ${table} WHERE organization_id = ?`,
                    [this.organizationId]
                );
                console.log(`[SyncManager] ğŸ—‘ï¸ Cleared local ${table}`);
            }

            // 2. Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† sync state Ù„Ø¥Ø¬Ø¨Ø§Ø± Ø§Ù„Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
            await this.pullEngine.resetSyncState(tableNames);

            // 3. Ø³Ø­Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø¬Ø¯ÙŠØ¯
            const results: Record<string, PullResult> = {};
            for (const table of tableNames) {
                const result = await this.pullEngine.pullTable(table);
                results[table] = result;
            }

            console.log('[SyncManager] âœ… Force re-sync complete:', results);

            // Dispatch event
            this.dispatchEvent('force-resync-complete', { tables: tableNames, results });

            return { success: true, results };
        } catch (error: any) {
            console.error('[SyncManager] âŒ Force re-sync failed:', error);
            return { success: false, results: {} };
        }
    }

    /**
     * âš¡ Re-sync products from Supabase (fix missing products issue)
     */
    async resyncProducts(): Promise<PullResult> {
        const result = await this.forceFullResync(['products']);
        return result.results['products'] || { processed: 0, skipped: 0, errors: 1 };
    }

    /**
     * âš¡ Fix orders in Supabase that have no items
     * ÙŠØ¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª ÙÙŠ Supabase Ø§Ù„ØªÙŠ Ù„ÙŠØ³ Ù„Ù‡Ø§ items ÙˆÙŠØ­Ø§ÙˆÙ„ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù…Ù† Ø§Ù„Ù…Ø­Ù„ÙŠ
     */
    async fixOrdersWithoutItems(): Promise<{ fixed: number; notFound: number; errors: string[] }> {
        if (!this.organizationId) {
            return { fixed: 0, notFound: 0, errors: ['No organization ID set'] };
        }

        const result = { fixed: 0, notFound: 0, errors: [] as string[] };

        try {
            // 1. Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ø§Ù„ØªÙŠ Ù„Ù‡Ø§ items
            const localOrdersWithItems = await sqliteWriteQueue.read<{ order_id: string; items_count: number }[]>(`
                SELECT o.id as order_id, COUNT(oi.id) as items_count
                FROM orders o
                LEFT JOIN order_items oi ON oi.order_id = o.id
                WHERE o.organization_id = ?
                GROUP BY o.id
                HAVING items_count > 0
                ORDER BY o.created_at DESC
                LIMIT 100
            `, [this.organizationId]);

            console.log(`[SyncManager] ğŸ” Found ${localOrdersWithItems.length} local orders with items`);

            // 2. Ù„ÙƒÙ„ Ø·Ù„Ø¨ØŒ Ù†Ø¶ÙŠÙ items Ù„Ù„Ù€ outbox Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
            for (const orderInfo of localOrdersWithItems) {
                try {
                    // Ø¬Ù„Ø¨ items Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨
                    const items = await sqliteWriteQueue.read<Record<string, unknown>[]>(`
                        SELECT * FROM order_items WHERE order_id = ?
                    `, [orderInfo.order_id]);

                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù‡Ø°Ù‡ Ø§Ù„Ù€ items ÙÙŠ outbox
                    for (const item of items) {
                        const existsInOutbox = await sqliteWriteQueue.read<{ id: string }[]>(`
                            SELECT id FROM sync_outbox
                            WHERE table_name = 'order_items'
                            AND record_id = ?
                            AND status != 'sent'
                        `, [item.id]);

                        if (existsInOutbox.length === 0) {
                            // Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù€ outbox
                            await outboxManager.addOperation({
                                tableName: 'order_items',
                                operation: 'INSERT',
                                recordId: item.id as string,
                                payload: item,
                            });
                            result.fixed++;
                        }
                    }
                } catch (err: any) {
                    result.errors.push(`Order ${orderInfo.order_id}: ${err.message}`);
                }
            }

            console.log(`[SyncManager] âœ… Fixed ${result.fixed} order items, ${result.notFound} not found locally`);
        } catch (error: any) {
            console.error('[SyncManager] âŒ fixOrdersWithoutItems failed:', error);
            result.errors.push(error.message);
        }

        return result;
    }

    /**
     * âš¡ Clean up all failed and stuck operations
     */
    async cleanupAllOperations(): Promise<{ removed: number; requeued: number }> {
        let removed = 0;
        let requeued = 0;

        try {
            // 1. Remove corrupted entries
            removed += await outboxManager.removeCorruptedEntries();

            // 2. Remove schema errors
            removed += await outboxManager.removeSchemaErrors();

            // 3. Requeue stuck operations
            requeued = await outboxManager.requeueStuck();

            // 4. Auto-clean payloads
            const cleanResult = await outboxManager.autoCleanAllPayloads();
            removed += cleanResult.removed;

            console.log(`[SyncManager] ğŸ§¹ Cleanup complete: ${removed} removed, ${requeued} requeued`);
        } catch (error) {
            console.error('[SyncManager] âŒ Cleanup failed:', error);
        }

        return { removed, requeued };
    }

    /**
     * âš¡ CRITICAL FIX: Ø¯Ø§Ù„Ø© Ù„Ø¥ØµÙ„Ø§Ø­ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ù„Ù„Ø·Ù„Ø¨Ø§Øª
     * ØªØ­Ø¯Ø« synced = 1 Ù„Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªÙŠ ØªÙ… Ù…Ø²Ø§Ù…Ù†ØªÙ‡Ø§ Ù„ÙƒÙ† synced Ù„Ù… ÙŠÙØ­Ø¯Ù‘Ø«
     * ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù…Ù† syncDiagnostics
     */
    async fixOrdersSyncStatus(): Promise<{ fixed: number; total: number }> {
        if (!this.organizationId) {
            console.error('[SyncManager] âŒ Not initialized');
            return { fixed: 0, total: 0 };
        }

        try {
            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø¨Ø§Øª ØºÙŠØ± Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø© (Ù„ÙŠØ³Øª ÙÙŠ outbox)
            const unsyncedOrders = await sqliteWriteQueue.read<{ id: string }[]>(`
                SELECT o.id FROM orders o
                WHERE o.organization_id = ?
                AND (o.synced = 0 OR o.synced IS NULL)
                AND o.id NOT IN (
                    SELECT record_id FROM sync_outbox 
                    WHERE table_name = 'orders' AND status IN ('pending', 'sending', 'failed')
                )
            `, [this.organizationId]);

            const total = unsyncedOrders.length;
            if (total === 0) {
                console.log('[SyncManager] âœ… All orders are properly synced');
                return { fixed: 0, total: 0 };
            }

            // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©
            const ids = unsyncedOrders.map(o => o.id);
            const placeholders = ids.map(() => '?').join(',');

            await sqliteWriteQueue.write(`
                UPDATE orders SET synced = 1 WHERE id IN (${placeholders})
            `, ids);

            // ØªØ­Ø¯ÙŠØ« order_items Ø£ÙŠØ¶Ø§Ù‹
            try {
                await sqliteWriteQueue.write(`
                    UPDATE order_items SET synced = 1 
                    WHERE order_id IN (${placeholders}) AND (synced = 0 OR synced IS NULL)
                `, ids);
            } catch (err) {
                console.warn('[SyncManager] âš ï¸ Could not update order_items:', err);
            }

            console.log(`[SyncManager] âœ… Fixed ${total} orders sync status`);
            return { fixed: total, total };
        } catch (error) {
            console.error('[SyncManager] âŒ Failed to fix orders sync status:', error);
            return { fixed: 0, total: 0 };
        }
    }
}

// ============================================
// ğŸ“¤ Export Singleton
// ============================================

export const syncManager = SyncManager.getInstance();

// ============================================
// ğŸ› ï¸ Diagnostics (Development)
// ============================================

if (typeof window !== 'undefined') {
    (window as Record<string, unknown>).syncDiagnostics = {
        stats: () => syncManager.getStats(),
        forceSync: () => syncManager.forceSync(),
        syncTable: (table: string) => syncManager.syncTable(table),
        pendingOps: async () => {
            const stats = await outboxManager.getStats();
            const details = await outboxManager.getDetailedPending();
            console.log('ğŸ“Š Outbox Stats:', stats);
            console.table(details);
            return { stats, details };
        },
        cleanPayloads: () => outboxManager.autoCleanAllPayloads(),
        clearOutbox: () => outboxManager.clear(),
        backfillOrders: () => syncManager.backfillUnsyncedOrders(),
        // âš¡ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø²Ø§Ù…Ù†Ø© ÙƒØ§Ù…Ù„Ø© Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ø­Ø¯Ø¯Ø©
        forceResync: (tables: string[]) => syncManager.forceFullResync(tables),
        // âš¡ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª (Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© 35 â†’ 29)
        resyncProducts: () => syncManager.resyncProducts(),
        // âš¡ Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø¨Ø¯ÙˆÙ† items ÙÙŠ Supabase
        fixOrdersWithoutItems: () => syncManager.fixOrdersWithoutItems(),
        // âš¡ ØªÙ†Ø¸ÙŠÙ Ø´Ø§Ù…Ù„ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ÙØ§Ø´Ù„Ø©
        cleanupAll: () => syncManager.cleanupAllOperations(),
        // âš¡ CRITICAL FIX: Ø¥ØµÙ„Ø§Ø­ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ù„Ù„Ø·Ù„Ø¨Ø§Øª
        fixOrdersSyncStatus: () => syncManager.fixOrdersSyncStatus(),
        // âš¡ Phase 1: Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©
        runOfflineTest: async () => {
            if (!syncManager.orgId) {
                console.error('[syncDiagnostics] âŒ No organization ID set');
                return { totalTests: 0, passed: 0, failed: 0, duration: 0, results: [] };
            }
            try {
                const { createOfflineSyncTest } = await import('../testing/OfflineSyncTest');
                const test = createOfflineSyncTest(syncManager.orgId);
                return await test.runFullTest();
            } catch (error: any) {
                console.error('[syncDiagnostics] âŒ Failed to run offline test:', error);
                return { totalTests: 0, passed: 0, failed: 1, duration: 0, results: [{ name: 'Test Setup', passed: false, duration: 0, error: error.message }] };
            }
        },
        // âš¡ Phase 3: ØµÙŠØ§Ù†Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        runMaintenance: async () => {
            if (!syncManager.orgId) {
                console.error('[syncDiagnostics] âŒ No organization ID set');
                return { totalOperations: 0, successful: 0, failed: 0, totalDuration: 0, results: [] };
            }
            try {
                const { createDatabaseMaintenance } = await import('../maintenance/DatabaseMaintenance');
                const maintenance = createDatabaseMaintenance(syncManager.orgId);
                return await maintenance.runFullMaintenance();
            } catch (error: any) {
                console.error('[syncDiagnostics] âŒ Failed to run maintenance:', error);
                return { totalOperations: 0, successful: 0, failed: 1, totalDuration: 0, results: [{ success: false, operation: 'setup', duration: 0, error: error.message }] };
            }
        },
        getMaintenanceStats: async () => {
            if (!syncManager.orgId) {
                console.error('[syncDiagnostics] âŒ No organization ID set');
                return {};
            }
            try {
                const { createDatabaseMaintenance } = await import('../maintenance/DatabaseMaintenance');
                const maintenance = createDatabaseMaintenance(syncManager.orgId);
                return await maintenance.getDatabaseStats();
            } catch (error: any) {
                console.error('[syncDiagnostics] âŒ Failed to get maintenance stats:', error);
                return { error: error.message };
            }
        },
    };

    console.log('[SyncManager] ğŸ› ï¸ Diagnostics available: window.syncDiagnostics');
    console.log('[SyncManager] ğŸ’¡ Commands:');
    console.log('  - syncDiagnostics.resyncProducts() â†’ Fix missing products (35â†’29)');
    console.log('  - syncDiagnostics.fixOrdersWithoutItems() â†’ Fix orders without items');
    console.log('  - syncDiagnostics.cleanupAll() â†’ Clean failed operations');
    console.log('  - syncDiagnostics.fixOrdersSyncStatus() â†’ Fix orders sync status (synced=0 â†’ synced=1)');
    console.log('  - syncDiagnostics.runOfflineTest() â†’ Run comprehensive offline sync tests');
    console.log('  - syncDiagnostics.runMaintenance() â†’ Run database maintenance (vacuum, analyze, cleanup)');
    console.log('  - syncDiagnostics.getMaintenanceStats() â†’ Get database statistics');
}

/**
 * RealtimeReceiver - Supabase Realtime Subscription Handler
 * Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ© Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù… Ø¹Ø¨Ø± Supabase Realtime
 *
 * âš¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Exponential Backoff Ù…Ø¹ Jitter
 *
 * ÙŠØ³ØªØ®Ø¯Ù… postgres_changes Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„ØªØºÙŠÙŠØ±Ø§Øª operations_log
 * ÙƒÙ„ ØªØºÙŠÙŠØ± ÙŠÙØ±Ø³Ù„ Ù„Ù€ OperationQueue Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨
 */

import { supabase } from '@/lib/supabase-unified';
import { RealtimeChannel } from '@supabase/supabase-js';
import {
  ServerOperation,
  RealtimeCallback,
  DELTA_SYNC_CONSTANTS
} from './types';
import { connectionState } from './ConnectionState';

export class RealtimeReceiver {
  private channel: RealtimeChannel | null = null;
  private organizationId: string | null = null;
  private callback: RealtimeCallback | null = null;
  private isSubscribed = false;
  private reconnectAttempts = 0;
  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;
  private deviceId: string;
  private lastSuccessfulConnection: number = 0;

  // âš¡ Ø«ÙˆØ§Ø¨Øª Ù…Ø­Ø³Ù‘Ù†Ø© Ù„Ù„Ù€ Reconnect
  private readonly MAX_RECONNECT_ATTEMPTS = 10; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
  private readonly RECONNECT_BASE_DELAY = 1000; // 1 Ø«Ø§Ù†ÙŠØ©
  private readonly MAX_RECONNECT_DELAY = 60000; // 60 Ø«Ø§Ù†ÙŠØ© max
  private readonly JITTER_FACTOR = 0.3; // Â±30% jitter

  // âš¡ ØªØªØ¨Ø¹ Ø¢Ø®Ø± Ø·Ø¨Ø§Ø¹Ø© Ù„Ù€ offline log Ù„ØªÙ‚Ù„ÙŠÙ„ spam
  private lastOfflineLogTime: number = 0;
  private readonly OFFLINE_LOG_INTERVAL_MS = 30000; // 30 Ø«Ø§Ù†ÙŠØ©

  constructor() {
    this.deviceId = this.getDeviceId();
    
    // âš¡ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ø­Ø¯Ø« Ø¹ÙˆØ¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„Ø¹Ø¯Ø§Ø¯ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
    if (typeof window !== 'undefined') {
      // Ø­Ø¯Ø« Ø§Ù„Ù…ØªØµÙØ­ Ø§Ù„Ø£ØµÙ„ÙŠ
      window.addEventListener('online', () => {
        console.log('%c[RealtimeReceiver] ğŸ“¶ Browser online event detected', 'color: #4CAF50');
        this.handleNetworkOnline();
      });
      
      // Ø­Ø¯Ø« connection-state-change Ø§Ù„Ù…Ø®ØµØµ
      window.addEventListener('connection-state-change', (e: any) => {
        if (e.detail?.isOnline) {
          console.log('%c[RealtimeReceiver] ğŸ“¶ Connection state change: online', 'color: #4CAF50');
          this.handleNetworkOnline();
        }
      });
    }
  }
  
  /**
   * âš¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹ÙˆØ¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ - Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„Ø¹Ø¯Ø§Ø¯ ÙˆÙ…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
   */
  private handleNetworkOnline(): void {
    // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
    this.reconnectAttempts = 0;
    this.lastOfflineLogTime = 0;
    
    // Ø¥Ù„ØºØ§Ø¡ Ø£ÙŠ timeout Ù…Ø¹Ù„Ù‚
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
    
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙ†Ø§ organizationId Ùˆ callback
    if (this.organizationId && this.callback && !this.isSubscribed) {
      console.log('%c[RealtimeReceiver] ğŸ”„ Attempting to reconnect after network recovery...', 'color: #2196F3');
      this.createSubscription();
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ device ID
   */
  private getDeviceId(): string {
    return localStorage.getItem('delta_sync_device_id') || 'unknown';
  }

  /**
   * Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ù…Ù†Ø¸Ù…Ø©
   */
  async subscribe(organizationId: string, callback: RealtimeCallback): Promise<void> {
    // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø¥Ù† ÙˆØ¬Ø¯
    if (this.isSubscribed) {
      await this.unsubscribe();
    }

    this.organizationId = organizationId;
    this.callback = callback;
    this.reconnectAttempts = 0;

    await this.createSubscription();
  }

  /**
   * Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Realtime
   */
  private async createSubscription(): Promise<void> {
    if (!this.organizationId || !this.callback) {
      // âš¡ ÙƒØªÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø¹Ø¯ (Ø·Ø¨ÙŠØ¹ÙŠ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚)
      if (this.reconnectAttempts > 0) {
        console.warn('[RealtimeReceiver] Cannot create subscription: missing organizationId or callback');
      }
      return;
    }

    try {
      // Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ù†Ø§Ø© Ø¬Ø¯ÙŠØ¯Ø©
      const channelName = `operations_${this.organizationId}_${Date.now()}`;

      this.channel = supabase.channel(channelName, {
        config: {
          broadcast: { self: false },
          presence: { key: this.deviceId }
        }
      });

      // Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„ØªØºÙŠÙŠØ±Ø§Øª operations_log
      this.channel
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'operations_log',
            filter: `organization_id=eq.${this.organizationId}`
          },
          (payload) => {
            this.handleInsert(payload.new as ServerOperation);
          }
        )
        .on('system', {}, (status) => {
          this.handleSystemStatus(status);
        })
        .subscribe((status) => {
          this.handleSubscriptionStatus(status);
        });

      console.log(`[RealtimeReceiver] Subscribing to operations for org ${this.organizationId}`);
    } catch (error) {
      console.error('[RealtimeReceiver] Subscription error:', error);
      this.scheduleReconnect();
    }
  }

  /**
   * Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù…Ù„ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
   */
  private handleInsert(operation: ServerOperation): void {
    // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø¬Ù‡Ø§Ø²
    if (operation.device_id === this.deviceId) {
      console.log(`[RealtimeReceiver] Ignoring own operation ${operation.server_seq}`);
      return;
    }

    console.log(`[RealtimeReceiver] Received operation ${operation.server_seq}: ${operation.operation} ${operation.table_name}`);

    // Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù€ callback (OperationQueue)
    if (this.callback) {
      try {
        this.callback(operation);
      } catch (error) {
        console.error('[RealtimeReceiver] Callback error:', error);
      }
    }
  }

  /**
   * âš¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ - Ù…Ø­Ø³Ù‘Ù† Ù…Ø¹ logging Ø£ÙØ¶Ù„
   */
  private handleSubscriptionStatus(status: string): void {
    switch (status) {
      case 'SUBSCRIBED':
        this.isSubscribed = true;
        this.reconnectAttempts = 0;
        this.lastSuccessfulConnection = Date.now();
        console.log('%c[RealtimeReceiver] âœ… Successfully subscribed to realtime updates', 'color: #4CAF50; font-weight: bold');
        break;

      case 'CLOSED':
        this.isSubscribed = false;
        const closedDuration = this.lastSuccessfulConnection > 0 
          ? Math.round((Date.now() - this.lastSuccessfulConnection) / 1000) + 's'
          : 'N/A';
        console.warn(`%c[RealtimeReceiver] âš ï¸ Channel CLOSED (was connected for ${closedDuration}), will reconnect`, 'color: #FF9800');
        this.scheduleReconnect();
        break;

      case 'CHANNEL_ERROR':
        this.isSubscribed = false;
        // âš¡ ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù€ spam - Ø·Ø¨Ø§Ø¹Ø© warn Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† error (Ù‡Ø°Ø§ Ø·Ø¨ÙŠØ¹ÙŠ Ø¥Ø°Ø§ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯)
        if (this.reconnectAttempts === 0) {
          console.warn('%c[RealtimeReceiver] âš ï¸ Channel ERROR (operations_log table may not exist), will retry', 'color: #FF9800');
        }
        this.scheduleReconnect();
        break;

      case 'TIMED_OUT':
        this.isSubscribed = false;
        console.warn('%c[RealtimeReceiver] â±ï¸ Subscription TIMED OUT, will reconnect', 'color: #FF9800');
        this.scheduleReconnect();
        break;

      default:
        console.log(`[RealtimeReceiver] Status: ${status}`);
    }
  }

  /**
   * Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…
   */
  private handleSystemStatus(status: any): void {
    if (status.type === 'error') {
      console.error('[RealtimeReceiver] System error:', status);
    }
  }

  /**
   * âš¡ Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹ Exponential Backoff + Jitter
   */
  private scheduleReconnect(): void {
    // âš¡ Ù„Ø§ ØªØ­Ø§ÙˆÙ„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ organizationId Ø£Ùˆ callback
    if (!this.organizationId || !this.callback) {
      return;
    }

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    // âš¡ ÙØ­Øµ Ù…Ø²Ø¯ÙˆØ¬: navigator.onLine + ConnectionState
    const isNavigatorOffline = typeof navigator !== 'undefined' && !navigator.onLine;
    const isConnectionStateOffline = connectionState.isOffline();

    // âš¡ Ù„Ø§ ØªØ­Ø§ÙˆÙ„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¥Ø°Ø§ ÙƒÙ†Ø§ offline
    if (isNavigatorOffline || isConnectionStateOffline) {
      const now = Date.now();
      // âš¡ Ø·Ø¨Ø§Ø¹Ø© log Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ© ÙÙ‚Ø·
      if (now - this.lastOfflineLogTime >= this.OFFLINE_LOG_INTERVAL_MS) {
        console.log('%c[RealtimeReceiver] ğŸ“´ Network offline, waiting for connection...', 'color: #FF9800');
        this.lastOfflineLogTime = now;
      }

      // âš¡ ÙØ­Øµ Ø¯ÙˆØ±ÙŠ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ - Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ØªØªÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ø¨Ø± event listeners ÙÙŠ constructor
      this.reconnectTimeout = setTimeout(() => {
        this.scheduleReconnect();
      }, 5000);
      return;
    }

    // âš¡ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† offline log time Ø¹Ù†Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„
    this.lastOfflineLogTime = 0;

    if (this.reconnectAttempts >= this.MAX_RECONNECT_ATTEMPTS) {
      console.error(`%c[RealtimeReceiver] âŒ Max reconnect attempts (${this.MAX_RECONNECT_ATTEMPTS}) reached, stopping`, 'color: #f44336; font-weight: bold');
      return;
    }

    // âš¡ Exponential backoff: 2^n * base
    const exponentialDelay = Math.pow(2, this.reconnectAttempts) * this.RECONNECT_BASE_DELAY;
    
    // âš¡ Jitter: Â±30% Ù„ØªØ¬Ù†Ø¨ thundering herd
    const jitter = exponentialDelay * this.JITTER_FACTOR * (Math.random() * 2 - 1);
    
    // âš¡ Cap at max delay
    const delay = Math.min(exponentialDelay + jitter, this.MAX_RECONNECT_DELAY);
    
    this.reconnectAttempts++;

    // âš¡ Ø·Ø¨Ø§Ø¹Ø© log ÙÙ‚Ø· Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø£Ùˆ ÙƒÙ„ 5 Ù…Ø­Ø§ÙˆÙ„Ø§Øª
    if (this.reconnectAttempts <= 2 || this.reconnectAttempts % 5 === 0) {
      console.log(`%c[RealtimeReceiver] ğŸ”„ Reconnecting in ${Math.round(delay)}ms (attempt ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS})`, 'color: #2196F3');
    }

    this.reconnectTimeout = setTimeout(() => {
      this.createSubscription();
    }, delay);
  }

  /**
   * Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
   */
  async unsubscribe(): Promise<void> {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.channel) {
      try {
        await supabase.removeChannel(this.channel);
      } catch (error) {
        console.warn('[RealtimeReceiver] Error removing channel:', error);
      }
      this.channel = null;
    }

    this.isSubscribed = false;
    this.callback = null;
    console.log('[RealtimeReceiver] Unsubscribed');
  }

  /**
   * Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙŠØ¯ÙˆÙŠØ§Ù‹
   */
  async reconnect(): Promise<void> {
    if (!this.organizationId || !this.callback) {
      console.warn('[RealtimeReceiver] Cannot reconnect without org and callback');
      return;
    }

    await this.unsubscribe();
    this.reconnectAttempts = 0;
    await this.subscribe(this.organizationId, this.callback);
  }

  /**
   * Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù…
   * ÙŠÙØ³ØªØ®Ø¯Ù… Ù„Ù…Ù„Ø¡ gaps ÙÙŠ Ø§Ù„ØªØ³Ù„Ø³Ù„
   */
  async fetchMissingOperations(startSeq: number, endSeq: number): Promise<ServerOperation[]> {
    if (!this.organizationId) {
      return [];
    }

    try {
      // @ts-ignore - operations_log ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Supabase types
      const { data, error } = await supabase
        .from('operations_log' as any)
        .select('*')
        .eq('organization_id', this.organizationId)
        .gte('server_seq', startSeq)
        .lte('server_seq', endSeq)
        .order('server_seq', { ascending: true });

      if (error) {
        // ÙƒØªÙ… Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
        return [];
      }

      return (data as unknown as ServerOperation[]) || [];
    } catch {
      return [];
    }
  }

  /**
   * Ø¬Ù„Ø¨ Ø£Ø­Ø¯Ø« Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ù†Ø° server_seq Ù…Ø¹ÙŠÙ†
   */
  async fetchOperationsSince(sinceSeq: number, limit: number = 1000): Promise<ServerOperation[]> {
    if (!this.organizationId) {
      return [];
    }

    try {
      // @ts-ignore - operations_log ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Supabase types
      const { data, error } = await supabase
        .from('operations_log' as any)
        .select('*')
        .eq('organization_id', this.organizationId)
        .gt('server_seq', sinceSeq)
        .order('server_seq', { ascending: true })
        .limit(limit);

      if (error) {
        // ÙƒØªÙ… Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
        return [];
      }

      return (data as unknown as ServerOperation[]) || [];
    } catch {
      return [];
    }
  }

  /**
   * Ø¬Ù„Ø¨ Ø£Ø­Ø¯Ø« server_seq Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù…
   */
  async getLatestServerSeq(): Promise<number> {
    if (!this.organizationId) {
      return 0;
    }

    try {
      // @ts-ignore - operations_log ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Supabase types
      const { data, error } = await supabase
        .from('operations_log' as any)
        .select('server_seq')
        .eq('organization_id', this.organizationId)
        .order('server_seq', { ascending: false })
        .limit(1)
        .single();

      if (error) {
        // PGRST116 = No rows, 406/42P01 = Table doesn't exist
        if (error.code === 'PGRST116' || error.code === '42P01' || error.message?.includes('406')) {
          return 0;
        }
        // ÙƒØªÙ… Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø£Ø®Ø±Ù‰ - Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‚Ø¯ Ù„Ø§ ÙŠÙƒÙˆÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ Ø¨Ø¹Ø¯
        return 0;
      }

      return (data as any)?.server_seq || 0;
    } catch {
      // Ø§Ù„Ø¬Ø¯ÙˆÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - Ù‡Ø°Ø§ Ø·Ø¨ÙŠØ¹ÙŠ
      return 0;
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
   */
  getStatus(): {
    isSubscribed: boolean;
    organizationId: string | null;
    reconnectAttempts: number;
    deviceId: string;
  } {
    return {
      isSubscribed: this.isSubscribed,
      organizationId: this.organizationId,
      reconnectAttempts: this.reconnectAttempts,
      deviceId: this.deviceId
    };
  }

  /**
   * ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø§ØªØµØ§Ù„
   */
  isHealthy(): boolean {
    return this.isSubscribed && this.channel !== null;
  }
}

// Export singleton instance
export const realtimeReceiver = new RealtimeReceiver();

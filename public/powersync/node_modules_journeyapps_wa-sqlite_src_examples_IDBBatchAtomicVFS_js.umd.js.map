{"version":3,"file":"worker/node_modules_journeyapps_wa-sqlite_src_examples_IDBBatchAtomicVFS_js.umd.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/FacadeVFS.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/VFS.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/WebLocksMixin.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js"],"sourcesContent":["// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './VFS.js';\n\nconst AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\n// Milliseconds since Julian epoch as a BigInt.\n// https://github.com/sqlite/sqlite/blob/e57527c14f7b7cfa6e32eeab5c549d50c4fa3674/src/os_unix.c#L6872-L6882\nconst UNIX_EPOCH = 24405875n * 8640000n;\n\n// Convenience base class for a JavaScript VFS.\n// The raw xOpen, xRead, etc. function signatures receive only C primitives\n// which aren't easy to work with. This class provides corresponding calls\n// like jOpen, jRead, etc., which receive JavaScript-friendlier arguments\n// such as string, Uint8Array, and DataView.\nexport class FacadeVFS extends VFS.Base {\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    super(name, module);\n  }\n\n  /**\n   * Override to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    // The input argument is a string like \"xOpen\", so convert to \"jOpen\".\n    // Then check if the method exists and is async.\n    const jMethodName = `j${methodName.slice(1)}`;\n    return this[jMethodName] instanceof AsyncFunction;\n  }\n  \n  /**\n   * Return the filename for a file id for use by mixins.\n   * @param {number} pFile \n   * @returns {string}\n   */\n  getFilename(pFile) {\n    throw new Error('unimplemented');\n  }\n\n  /**\n   * @param {string?} filename \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  jOpen(filename, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  jDelete(filename, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jAccess(filename, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {Uint8Array} zOut \n   * @returns {number|Promise<number>}\n   */\n  jFullPathname(filename, zOut) {\n    // Copy the filename to the output buffer.\n    const { read, written } = new TextEncoder().encodeInto(filename, zOut);\n    if (read < filename.length) return VFS.SQLITE_IOERR;\n    if (written >= zOut.length) return VFS.SQLITE_IOERR;\n    zOut[written] = 0;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns {number|Promise<number>}\n   */\n  jGetLastError(zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  jClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jRead(pFile, pData, iOffset) {\n    pData.fill(0);\n    return VFS.SQLITE_IOERR_SHORT_READ;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jWrite(pFile, pData, iOffset) {\n    return VFS.SQLITE_IOERR_WRITE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} size \n   * @returns {number|Promise<number>}\n   */\n  jTruncate(pFile, size) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  jSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pSize\n   * @returns {number|Promise<number>}\n   */\n  jFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jCheckReservedLock(pFile, pResOut) {\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jSectorSize(pFile) {\n    return super.xSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jDeviceCharacteristics(pFile) {\n    return 0;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    const filename = this.#decodeFilename(zName, flags);\n    const pOutFlagsView = this.#makeTypedDataView('Int32', pOutFlags);\n    this['log']?.('jOpen', filename, pFile, '0x' + flags.toString(16));\n    return this.jOpen(filename, pFile, flags, pOutFlagsView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nByte \n   * @param {number} pCharOut\n   * @returns {number|Promise<number>}\n   */\n  xRandomness(pVfs, nByte, pCharOut) {\n    const randomArray = new Uint8Array(nByte);\n    crypto.getRandomValues(randomArray);\n    // Copy randomArray to the WebAssembly memory\n    const buffer = pCharOut; // Pointer to memory in WebAssembly\n    this._module.HEAPU8.set(randomArray, buffer); // Copy randomArray into memory starting at buffer\n    return nByte;\n  }\n\n  /**\n   * Gets the current time as milliseconds since Unix epoch\n   * @param {number} pVfs pointer to the VFS\n   * @param {number} pTime pointer to write the time value\n   * @returns {number} SQLite error code\n   */\n  xCurrentTimeInt64(pVfs, pTime) {\n    // Create a DataView to write the current time\n    const timeView = this.#makeTypedDataView('BigInt64', pTime);\n  \n    const currentTime = BigInt(Date.now());\n    // Convert the current time to milliseconds since Unix epoch\n    const value = UNIX_EPOCH + currentTime;\n    \n    // Write the time value to the pointer location\n    timeView.setBigInt64(0, value, true);\n    \n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    const filename = this._module.UTF8ToString(zName);\n    this['log']?.('jDelete', filename, syncDir);\n    return this.jDelete(filename, syncDir);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jAccess', filename, flags);\n    return this.jAccess(filename, flags, pResOutView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);\n    this['log']?.('jFullPathname', filename, nOut);\n    return this.jFullPathname(filename, zOutArray);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);\n    this['log']?.('jGetLastError', nBuf);\n    return this.jGetLastError(zBufArray);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    this['log']?.('jClose', pFile);\n    return this.jClose(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jRead', pFile, iAmt, iOffset);\n    return this.jRead(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jWrite', pFile, pDataArray, iOffset);\n    return this.jWrite(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    const size = delegalize(sizeLo, sizeHi);\n    this['log']?.('jTruncate', pFile, size);\n    return this.jTruncate(pFile, size);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    this['log']?.('jSync', pFile, flags);\n    return this.jSync(pFile, flags);\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    const pSizeView = this.#makeTypedDataView('BigInt64', pSize);\n    this['log']?.('jFileSize', pFile);\n    return this.jFileSize(pFile, pSizeView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    this['log']?.('jLock', pFile, lockType);\n    return this.jLock(pFile, lockType);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    this['log']?.('jUnlock', pFile, lockType);\n    return this.jUnlock(pFile, lockType);\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jCheckReservedLock', pFile);\n    return this.jCheckReservedLock(pFile, pResOutView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    const pArgView = new DataView(\n      this._module.HEAPU8.buffer,\n      this._module.HEAPU8.byteOffset + pArg);\n    this['log']?.('jFileControl', pFile, op, pArgView);\n    return this.jFileControl(pFile, op, pArgView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    this['log']?.('jSectorSize', pFile);\n    return this.jSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    this['log']?.('jDeviceCharacteristics', pFile);\n    return this.jDeviceCharacteristics(pFile);\n  }\n\n  /**\n   * Wrapped DataView for pointer arguments.\n   * Pointers to a single value are passed using a DataView-like class.\n   * This wrapper class prevents use of incorrect type or endianness, and\n   * reacquires the underlying buffer when the WebAssembly memory is resized.\n   * @param {'Int32'|'BigInt64'} type \n   * @param {number} byteOffset \n   * @returns {DataView}\n   */\n  #makeTypedDataView(type, byteOffset) {\n    // @ts-ignore\n    return new DataViewProxy(this._module, byteOffset, type);\n  }\n\n  /**\n   * Wrapped Uint8Array for buffer arguments.\n   * Memory blocks are passed as a Uint8Array-like class. This wrapper\n   * class reacquires the underlying buffer when the WebAssembly memory\n   * is resized.\n   * @param {number} byteOffset \n   * @param {number} byteLength \n   * @returns {Uint8Array}\n   */\n  #makeDataArray(byteOffset, byteLength) {\n    // @ts-ignore\n    return new Uint8ArrayProxy(this._module, byteOffset, byteLength);\n  }\n\n  #decodeFilename(zName, flags) {\n    if (flags & VFS.SQLITE_OPEN_URI) {\n      // The first null-terminated string is the URI path. Subsequent\n      // strings are query parameter keys and values.\n      // https://www.sqlite.org/c3ref/open.html#urifilenamesinsqlite3open\n      let pName = zName;\n      let state = 1;\n      const charCodes = [];\n      while (state) {\n        const charCode = this._module.HEAPU8[pName++];\n        if (charCode) {\n          charCodes.push(charCode);\n        } else {\n          if (!this._module.HEAPU8[pName]) state = null;\n          switch (state) {\n            case 1: // path\n              charCodes.push('?'.charCodeAt(0));\n              state = 2;\n              break;\n            case 2: // key\n              charCodes.push('='.charCodeAt(0));\n              state = 3;\n              break;\n            case 3: // value\n              charCodes.push('&'.charCodeAt(0));\n              state = 2;\n              break;\n          }\n        }\n      }\n      return  new TextDecoder().decode(new Uint8Array(charCodes));\n    }\n    return zName ? this._module.UTF8ToString(zName) : null;\n  }\n}\n\n// Emscripten \"legalizes\" 64-bit integer arguments by passing them as\n// two 32-bit signed integers.\nfunction delegalize(lo32, hi32) {\n  return (hi32 * 0x100000000) + lo32 + (lo32 < 0 ? 2**32 : 0);\n}\n\n// This class provides a Uint8Array-like interface for a WebAssembly memory\n// buffer. It is used to access memory blocks passed as arguments to\n// xRead, xWrite, etc. The class reacquires the underlying buffer when the\n// WebAssembly memory is resized, which can happen when the memory is\n// detached and resized by the WebAssembly module.\n//\n// Note that although this class implements the same methods as Uint8Array,\n// it is not a real Uint8Array and passing it to functions that expect\n// a Uint8Array may not work. Use subarray() to get a real Uint8Array\n// if needed.\nclass Uint8ArrayProxy {\n  #module;\n\n  #_array = new Uint8Array()\n  get #array() {\n    if (this.#_array.buffer.byteLength === 0) {\n      // WebAssembly memory resize detached the buffer so re-create the\n      // array with the new buffer.\n      this.#_array = this.#module.HEAPU8.subarray(\n        this.byteOffset,\n        this.byteOffset + this.byteLength);\n    }\n    return this.#_array;\n  }\n\n  /**\n   * @param {*} module\n   * @param {number} byteOffset \n   * @param {number} byteLength \n   */\n  constructor(module, byteOffset, byteLength) {\n    this.#module = module;\n    this.byteOffset = byteOffset;\n    this.length = this.byteLength = byteLength;\n  }\n\n  get buffer() {\n    return this.#array.buffer;\n  }\n\n  at(index) {\n    return this.#array.at(index);\n  }\n  copyWithin(target, start, end) {\n    this.#array.copyWithin(target, start, end);\n  }\n  entries() {\n    return this.#array.entries();\n  }\n  every(predicate) {\n    return this.#array.every(predicate);\n  }\n  fill(value, start, end) {\n    this.#array.fill(value, start, end);\n  }\n  filter(predicate) {\n    return this.#array.filter(predicate);\n  }\n  find(predicate) {\n    return this.#array.find(predicate);\n  }\n  findIndex(predicate) {\n    return this.#array.findIndex(predicate);\n  }\n  findLast(predicate) {\n    return this.#array.findLast(predicate);\n  }\n  findLastIndex(predicate) {\n    return this.#array.findLastIndex(predicate);\n  }\n  forEach(callback) {\n    this.#array.forEach(callback);\n  }\n  includes(value, start) {\n    return this.#array.includes(value, start);\n  }\n  indexOf(value, start) {\n    return this.#array.indexOf(value, start);\n  }\n  join(separator) {\n    return this.#array.join(separator);\n  }\n  keys() {\n    return this.#array.keys();\n  }\n  lastIndexOf(value, start) {\n    return this.#array.lastIndexOf(value, start);\n  }\n  map(callback) {\n    return this.#array.map(callback);\n  }\n  reduce(callback, initialValue) {\n    return this.#array.reduce(callback, initialValue);\n  }\n  reduceRight(callback, initialValue) {\n    return this.#array.reduceRight(callback, initialValue);\n  }\n  reverse() {\n    this.#array.reverse();\n  }\n  set(array, offset) {\n    this.#array.set(array, offset);\n  }\n  slice(start, end) {\n    return this.#array.slice(start, end);\n  }\n  some(predicate) {\n    return this.#array.some(predicate);\n  }\n  sort(compareFn) {\n    this.#array.sort(compareFn);\n  }\n  subarray(begin, end) {\n    return this.#array.subarray(begin, end);\n  }\n  toLocaleString(locales, options) {\n    // @ts-ignore\n    return this.#array.toLocaleString(locales, options);\n  }\n  toReversed() {\n    return this.#array.toReversed();\n  }\n  toSorted(compareFn) {\n    return this.#array.toSorted(compareFn);\n  }\n  toString() {\n    return this.#array.toString();\n  }\n  values() {\n    return this.#array.values();\n  }\n  with(index, value) {\n    return this.#array.with(index, value);\n  }\n  [Symbol.iterator]() {\n    return this.#array[Symbol.iterator]();\n  }\n}\n\n// This class provides a DataView-like interface for a WebAssembly memory\n// buffer, restricted to either Int32 or BigInt64 types. It also reacquires\n// the underlying buffer when the WebAssembly memory is resized, which can\n// happen when the memory is detached and resized by the WebAssembly module.\nclass DataViewProxy {\n  #module;\n  #type;\n\n  #_view = new DataView(new ArrayBuffer(0));\n  get #view() {\n    if (this.#_view.buffer.byteLength === 0) {\n      // WebAssembly memory resize detached the buffer so re-create the\n      // view with the new buffer.\n      this.#_view = new DataView(\n        this.#module.HEAPU8.buffer,\n        this.#module.HEAPU8.byteOffset + this.byteOffset);\n    }\n    return this.#_view;\n  }\n\n  /**\n   * @param {*} module\n   * @param {number} byteOffset \n   * @param {'Int32'|'BigInt64'} type\n   */\n  constructor(module, byteOffset, type) {\n    this.#module = module;\n    this.byteOffset = byteOffset;\n    this.#type = type;\n  }\n\n  get buffer() {\n    return this.#view.buffer;\n  }\n  get byteLength() {\n    return this.#type === 'Int32' ? 4 : 8;\n  }\n\n  getInt32(byteOffset, littleEndian) {\n    if (this.#type !== 'Int32') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    return this.#view.getInt32(byteOffset, littleEndian);\n  }\n  setInt32(byteOffset, value, littleEndian) {\n    if (this.#type !== 'Int32') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    this.#view.setInt32(byteOffset, value, littleEndian);\n  }\n  getBigInt64(byteOffset, littleEndian) {\n    if (this.#type !== 'BigInt64') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    return this.#view.getBigInt64(byteOffset, littleEndian);\n  }\n  setBigInt64(byteOffset, value, littleEndian) {\n    if (this.#type !== 'BigInt64') {\n      throw new Error('invalid type');\n    }\n    if (!littleEndian) throw new Error('must be little endian');\n    this.#view.setBigInt64(byteOffset, value, littleEndian);\n  }\n}","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './sqlite-constants.js';\nexport * from './sqlite-constants.js';\n\nconst DEFAULT_SECTOR_SIZE = 512;\n\n// Base class for a VFS.\nexport class Base {\n  name;\n  mxPathname = 64;\n  _module;\n\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    this.name = name;\n    this._module = module;\n  }\n\n  /**\n   * @returns {void|Promise<void>} \n   */\n  close() {\n  }\n\n  /**\n   * @returns {boolean|Promise<boolean>}\n   */\n  isReady() {\n    return true;\n  }\n\n  /**\n   * Overload in subclasses to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    return false;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    return DEFAULT_SECTOR_SIZE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    return 0;\n  }\n}\n\nexport const FILE_TYPE_MASK = [\n  VFS.SQLITE_OPEN_MAIN_DB,\n  VFS.SQLITE_OPEN_MAIN_JOURNAL,\n  VFS.SQLITE_OPEN_TEMP_DB,\n  VFS.SQLITE_OPEN_TEMP_JOURNAL,\n  VFS.SQLITE_OPEN_TRANSIENT_DB,\n  VFS.SQLITE_OPEN_SUBJOURNAL,\n  VFS.SQLITE_OPEN_SUPER_JOURNAL,\n  VFS.SQLITE_OPEN_WAL\n].reduce((mask, element) => mask | element);","import * as VFS from './VFS.js';\n\n// Options for navigator.locks.request().\n/** @type {LockOptions} */ const SHARED = { mode: 'shared' };\n/** @type {LockOptions} */ const POLL_SHARED = { ifAvailable: true, mode: 'shared' };\n/** @type {LockOptions} */ const POLL_EXCLUSIVE = { ifAvailable: true, mode: 'exclusive' };\n\nconst POLICIES = ['exclusive', 'shared', 'shared+hint'];\n\n/**\n * @typedef LockState\n * @property {string} baseName\n * @property {number} type\n * @property {boolean} writeHint\n * \n * These properties are functions that release a specific lock.\n * @property {(() => void)?} [gate]\n * @property {(() => void)?} [access]\n * @property {(() => void)?} [reserved]\n * @property {(() => void)?} [hint]\n */\n\n/**\n * Mix-in for FacadeVFS that implements the SQLite VFS locking protocol.\n * @param {*} superclass FacadeVFS (or subclass)\n * @returns \n */\nexport const WebLocksMixin = superclass => class extends superclass {\n  #options = {\n    lockPolicy: 'exclusive',\n    lockTimeout: Infinity\n  };\n\n  /** @type {Map<number, LockState>} */ #mapIdToState = new Map();\n\n  constructor(name, module, options) {\n    super(name, module, options);\n    Object.assign(this.#options, options);\n    if (POLICIES.indexOf(this.#options.lockPolicy) === -1) {\n      throw new Error(`WebLocksMixin: invalid lock mode: ${options.lockPolicy}`);\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jLock(fileId, lockType) {\n    try {\n      // Create state on first lock.\n      if (!this.#mapIdToState.has(fileId)) {\n        const name = this.getFilename(fileId);\n        const state = {\n          baseName: name,\n          type: VFS.SQLITE_LOCK_NONE,\n          writeHint: false\n        };\n        this.#mapIdToState.set(fileId, state);\n      }\n\n      const lockState = this.#mapIdToState.get(fileId);\n      if (lockType <= lockState.type) return VFS.SQLITE_OK;\n  \n      switch (this.#options.lockPolicy) {\n        case 'exclusive':\n          return await this.#lockExclusive(lockState, lockType);\n        case 'shared':\n        case 'shared+hint':\n          return await this.#lockShared(lockState, lockType);\n      }\n    } catch (e) {\n      console.error('WebLocksMixin: lock error', e);\n      return VFS.SQLITE_IOERR_LOCK;\n    }\n  }\n  \n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jUnlock(fileId, lockType) {\n    try {\n      // SQLite can call xUnlock() without ever calling xLock() so\n      // the state may not exist.\n      const lockState = this.#mapIdToState.get(fileId);\n      if (!(lockType < lockState?.type)) return VFS.SQLITE_OK;\n  \n      switch (this.#options.lockPolicy) {\n        case 'exclusive':\n          return await this.#unlockExclusive(lockState, lockType);\n        case 'shared':\n        case 'shared+hint':\n            return await this.#unlockShared(lockState, lockType);\n      }\n    } catch (e) {\n      console.error('WebLocksMixin: unlock error', e);\n      return VFS.SQLITE_IOERR_UNLOCK;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pResOut \n   * @returns {Promise<number>}\n   */\n  async jCheckReservedLock(fileId, pResOut) {\n    try {\n      const lockState = this.#mapIdToState.get(fileId);\n      switch (this.#options.lockPolicy) {\n        case 'exclusive':\n          return this.#checkReservedExclusive(lockState, pResOut);\n        case 'shared':\n        case 'shared+hint':\n          return await this.#checkReservedShared(lockState, pResOut);\n      }\n    } catch (e) {\n      console.error('WebLocksMixin: check reserved lock error', e);\n      return VFS.SQLITE_IOERR_CHECKRESERVEDLOCK;\n    }\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(fileId, op, pArg) {\n    const lockState = this.#mapIdToState.get(fileId) ??\n      (() => {\n        // Call jLock() to create the lock state.\n        this.jLock(fileId, VFS.SQLITE_LOCK_NONE);\n        return this.#mapIdToState.get(fileId);\n      })();\n    if (op === WebLocksMixin.WRITE_HINT_OP_CODE &&\n        this.#options.lockPolicy === 'shared+hint'){\n      lockState.writeHint = true;\n    }\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns \n   */\n  async #lockExclusive(lockState, lockType) {\n    if (!lockState.access) {\n      if (!await this.#acquire(lockState, 'access')) {\n        return VFS.SQLITE_BUSY;\n      }\n      console.assert(!!lockState.access);\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns {number}\n   */\n  #unlockExclusive(lockState, lockType) {\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      lockState.access?.();\n      console.assert(!lockState.access);\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  #checkReservedExclusive(lockState, pResOut) {\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns \n   */\n  async #lockShared(lockState, lockType) {\n    switch (lockState.type) {\n      case VFS.SQLITE_LOCK_NONE:\n        switch (lockType) {\n          case VFS.SQLITE_LOCK_SHARED:\n            if (lockState.writeHint) {\n              // xFileControl() has hinted that this transaction will\n              // write. Acquire the hint lock, which is required to reach\n              // the RESERVED state.\n              if (!await this.#acquire(lockState, 'hint')) {\n                // Timeout before lock acquired.\n                return VFS.SQLITE_BUSY;\n              }\n            }\n\n            // Must have the gate lock to request the access lock.\n            if (!await this.#acquire(lockState, 'gate', SHARED)) {\n                // Timeout before lock acquired.\n                lockState.hint?.();\n              return VFS.SQLITE_BUSY;\n            }\n            await this.#acquire(lockState, 'access', SHARED);\n            lockState.gate();\n            console.assert(!lockState.gate);\n            console.assert(!!lockState.access);\n            console.assert(!lockState.reserved);\n            break;\n\n          default:\n            throw new Error('unsupported lock transition');\n        }\n        break;\n      case VFS.SQLITE_LOCK_SHARED:\n        switch (lockType) {\n          case VFS.SQLITE_LOCK_RESERVED:\n            if (this.#options.lockPolicy === 'shared+hint') {\n              // Ideally we should already have the hint lock, but if not\n              // poll for it here.\n              if (!lockState.hint &&\n                !await this.#acquire(lockState, 'hint', POLL_EXCLUSIVE)) {\n                // Another connection has the hint lock so this is a\n                // deadlock. This connection must retry.\n                return VFS.SQLITE_BUSY;\n              }\n            }\n\n            // Poll for the reserved lock. This should always succeed\n            // if all clients use the 'shared+hint' policy.\n            if (!await this.#acquire(lockState, 'reserved', POLL_EXCLUSIVE)) {\n              // This is a deadlock. The connection holding the reserved\n              // lock blocks us, and it can't acquire an exclusive access\n              // lock because we hold a shared access lock. This connection\n              // must retry.\n              lockState.hint?.();\n              return VFS.SQLITE_BUSY;\n            }\n            lockState.access();\n            console.assert(!lockState.gate);\n            console.assert(!lockState.access);\n            console.assert(!!lockState.reserved);\n            break;\n\n          case VFS.SQLITE_LOCK_EXCLUSIVE:\n            // Jumping directly from SHARED to EXCLUSIVE without passing\n            // through RESERVED is only done with a hot journal.\n            if (!await this.#acquire(lockState, 'gate')) {\n              // Timeout before lock acquired.\n              return VFS.SQLITE_BUSY;\n            }\n            lockState.access();\n            if (!await this.#acquire(lockState, 'access')) {\n              // Timeout before lock acquired.\n              lockState.gate();\n              return VFS.SQLITE_BUSY;\n            }\n            console.assert(!!lockState.gate);\n            console.assert(!!lockState.access);\n            console.assert(!lockState.reserved);\n            break;\n\n          default:\n            throw new Error('unsupported lock transition');\n        }\n        break;\n      case VFS.SQLITE_LOCK_RESERVED:\n        switch (lockType) {\n          case VFS.SQLITE_LOCK_EXCLUSIVE:\n            // Prevent other connections from entering the SHARED state.\n            if (!await this.#acquire(lockState, 'gate')) {\n              // Timeout before lock acquired.\n              return VFS.SQLITE_BUSY;\n            }\n\n            // Block until all other connections exit the SHARED state.\n            if (!await this.#acquire(lockState, 'access')) {\n              // Timeout before lock acquired.\n              lockState.gate();\n              return VFS.SQLITE_BUSY;\n            }\n            console.assert(!!lockState.gate);\n            console.assert(!!lockState.access);\n            console.assert(!!lockState.reserved);\n            break;\n\n          default:\n            throw new Error('unsupported lock transition');\n        }\n        break;\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns \n   */\n  async #unlockShared(lockState, lockType) {\n    // lockType can only be SQLITE_LOCK_SHARED or SQLITE_LOCK_NONE.\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      lockState.access?.();\n      lockState.gate?.();\n      lockState.reserved?.();\n      lockState.hint?.();\n      lockState.writeHint = false;\n      console.assert(!lockState.access);\n      console.assert(!lockState.gate);\n      console.assert(!lockState.reserved);\n      console.assert(!lockState.hint);\n    } else { // lockType === VFS.SQLITE_LOCK_SHARED\n      switch (lockState.type) {\n        case VFS.SQLITE_LOCK_EXCLUSIVE:\n          // Release our exclusive access lock and reacquire it with a\n          // shared lock. This should always succeed because we hold\n          // the gate lock.\n          lockState.access();\n          await this.#acquire(lockState, 'access', SHARED);\n\n          // Release our gate and reserved locks. We might not have a\n          // reserved lock if we were handling a hot journal.\n          lockState.gate();\n          lockState.reserved?.();\n          lockState.hint?.();\n          console.assert(!!lockState.access);\n          console.assert(!lockState.gate);\n          console.assert(!lockState.reserved);\n          break;\n\n        case VFS.SQLITE_LOCK_RESERVED:\n          // This transition is rare, probably only on an I/O error\n          // while writing to a journal file.\n          await this.#acquire(lockState, 'access', SHARED);\n          lockState.reserved();\n          lockState.hint?.();\n          console.assert(!!lockState.access);\n          console.assert(!lockState.gate);\n          console.assert(!lockState.reserved);\n          break;\n      }\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {DataView} pResOut \n   * @returns {Promise<number>}\n   */\n  async #checkReservedShared(lockState, pResOut) {\n    if (await this.#acquire(lockState, 'reserved', POLL_SHARED)) {\n      // We were able to get the lock so it was not reserved.\n      lockState.reserved();\n      pResOut.setInt32(0, 0, true);\n    } else {\n      pResOut.setInt32(0, 1, true);\n    }\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {'gate'|'access'|'reserved'|'hint'} name\n   * @param {LockOptions} options \n   * @returns {Promise<boolean>}\n   */\n  #acquire(lockState, name, options = {}) {\n    console.assert(!lockState[name]);\n    return new Promise(resolve => {\n      if (!options.ifAvailable && this.#options.lockTimeout < Infinity) {\n        // Add a timeout to the lock request.\n        const controller = new AbortController();\n        options = Object.assign({}, options, { signal: controller.signal });\n        setTimeout(() => {\n          controller.abort();\n          resolve?.(false);\n        }, this.#options.lockTimeout);\n      }\n\n      const lockName = `lock##${lockState.baseName}##${name}`;\n      navigator.locks.request(lockName, options, lock => {\n        if (lock) {\n          return new Promise(release => {\n            lockState[name] = () => {\n              release();\n              lockState[name] = null;\n            };\n            resolve(true);\n            resolve = null;\n          });\n        } else {\n          lockState[name] = null;\n          resolve(false);\n          resolve = null;\n        }\n      }).catch(e => {\n        if (e.name !== 'AbortError') throw e;\n      });\n    });\n  }\n}\n\nWebLocksMixin.WRITE_HINT_OP_CODE = -9999;","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport { FacadeVFS } from '../FacadeVFS.js';\nimport * as VFS from '../VFS.js';\nimport { WebLocksMixin } from '../WebLocksMixin.js';\n\nconst RETRYABLE_ERRORS = new Set([\n  'TransactionInactiveError',\n  'InvalidStateError'\n]);\n\n/**\n * @typedef Metadata\n * @property {string} name\n * @property {number} fileSize\n * @property {number} version\n * @property {number} [pendingVersion]\n */\n\nclass File {\n  /** @type {string} */ path;\n  /** @type {number} */ flags;\n\n  /** @type {Metadata} */ metadata;\n  /** @type {number} */ fileSize = 0;\n\n  /** @type {boolean} */ needsMetadataSync = false;\n  /** @type {Metadata} */ rollback = null;\n  /** @type {Set<number>} */ changedPages = new Set();\n\n  /** @type {string} */ synchronous = 'full';\n  /** @type {IDBTransactionOptions} */ txOptions = { durability: 'strict' };\n\n  constructor(path, flags, metadata) {\n    this.path = path;\n    this.flags = flags;\n    this.metadata = metadata;\n  }\n}\n\nexport class IDBBatchAtomicVFS extends WebLocksMixin(FacadeVFS) {\n  /** @type {Map<number, File>} */ mapIdToFile = new Map();\n  lastError = null;\n\n  log = null; // console.log\n\n  /** @type {Promise} */ #isReady;\n  /** @type {IDBContext} */ #idb;\n\n  static async create(name, module, options) {\n    const vfs = new IDBBatchAtomicVFS(name, module, options);\n    await vfs.isReady();\n    return vfs;\n  }\n\n  constructor(name, module, options = {}) {\n    super(name, module, options);\n    this.#isReady = this.#initialize(options.idbName ?? name);\n  }\n\n  async #initialize(name) {\n    this.#idb = await IDBContext.create(name);\n  }\n\n  close() {\n    this.#idb.close();\n  }\n  \n  async isReady() {\n    await super.isReady();\n    await this.#isReady;\n  }\n\n  getFilename(fileId) {\n    const pathname = this.mapIdToFile.get(fileId).path;\n    return `IDB(${this.name}):${pathname}`\n  }\n  \n  /**\n   * @param {string?} zName \n   * @param {number} fileId \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {Promise<number>}\n   */\n  async jOpen(zName, fileId, flags, pOutFlags) {\n    try {\n      const url = new URL(zName || Math.random().toString(36).slice(2), 'file://');\n      const path = url.pathname;\n\n      let meta = await this.#idb.q(({ metadata }) => metadata.get(path));\n      if (!meta && (flags & VFS.SQLITE_OPEN_CREATE)) {\n        meta = {\n          name: path,\n          fileSize: 0,\n          version: 0\n        };\n        await this.#idb.q(({ metadata }) => metadata.put(meta), 'rw');\n      }\n      \n      if (!meta) {\n        throw new Error(`File ${path} not found`);\n      }\n\n      const file = new File(path, flags, meta);\n      this.mapIdToFile.set(fileId, file);\n      pOutFlags.setInt32(0, flags, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_CANTOPEN;\n    }\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} syncDir \n   * @returns {Promise<number>}\n   */\n  async jDelete(zName, syncDir) {\n    try {\n      const url = new URL(zName, 'file://');\n      const path = url.pathname;\n\n      this.#idb.q(({ metadata, blocks }) => {\n        const range = IDBKeyRange.bound([path, -Infinity], [path, Infinity]);\n        blocks.delete(range);\n        metadata.delete(path);\n      }, 'rw');\n\n      if (syncDir) {\n        await this.#idb.sync(false);\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_DELETE;\n    }\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {Promise<number>}\n   */\n  async jAccess(zName, flags, pResOut) {\n    try {\n      const url = new URL(zName, 'file://');\n      const path = url.pathname;\n\n      const meta = await this.#idb.q(({ metadata }) => metadata.get(path));\n      pResOut.setInt32(0, meta ? 1 : 0, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_ACCESS;\n    } \n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {Promise<number>}\n   */\n  async jClose(fileId) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      this.mapIdToFile.delete(fileId);\n\n      if (file.flags & VFS.SQLITE_OPEN_DELETEONCLOSE) {\n        await this.#idb.q(({ metadata, blocks }) => {\n          metadata.delete(file.path);\n          blocks.delete(IDBKeyRange.bound([file.path, 0], [file.path, Infinity]));\n        }, 'rw');        \n      }\n\n      if (file.needsMetadataSync) {\n        this.#idb.q(({ metadata }) => metadata.put(file.metadata), 'rw');\n      }\n      await this.#idb.sync(file.synchronous === 'full');\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_CLOSE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {Promise<number>}\n   */\n  async jRead(fileId, pData, iOffset) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n\n      let pDataOffset = 0;\n      while (pDataOffset < pData.byteLength) {\n        // Fetch the IndexedDB block for this file location.\n        const fileOffset = iOffset + pDataOffset;\n        const block = await this.#idb.q(({ blocks }) => {\n          const range = IDBKeyRange.bound([file.path, -fileOffset], [file.path, Infinity]);\n          return blocks.get(range);\n        });       \n        \n        if (!block || block.data.byteLength - block.offset <= fileOffset) {\n          pData.fill(0, pDataOffset);\n          return VFS.SQLITE_IOERR_SHORT_READ;\n        }\n\n        // Copy block data.\n        const dst = pData.subarray(pDataOffset);\n        const srcOffset = fileOffset + block.offset;\n        const nBytesToCopy = Math.min(\n          Math.max(block.data.byteLength - srcOffset, 0),\n          dst.byteLength);\n        dst.set(block.data.subarray(srcOffset, srcOffset + nBytesToCopy));\n        pDataOffset += nBytesToCopy;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_READ;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  jWrite(fileId, pData, iOffset) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        if (!file.rollback) {\n          // Begin a new write transaction.\n          // Add pendingVersion to the metadata in IndexedDB. If we crash\n          // during the transaction, this lets subsequent connections\n          // know to remove blocks from the failed transaction.\n          const pending = Object.assign(\n            { pendingVersion: file.metadata.version - 1 },\n            file.metadata);\n          this.#idb.q(({ metadata }) => metadata.put(pending), 'rw', file.txOptions);\n\n          file.rollback = Object.assign({}, file.metadata);\n          file.metadata.version--;\n        }\n      }\n\n      if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        file.changedPages.add(iOffset);\n      }\n\n      const data = pData.slice();\n      const version = file.metadata.version;\n      const isOverwrite = iOffset < file.metadata.fileSize;\n      if (!isOverwrite ||\n          file.flags & VFS.SQLITE_OPEN_MAIN_DB ||\n          file.flags & VFS.SQLITE_OPEN_TEMP_DB) {\n        const block = {\n          path: file.path,\n          offset: -iOffset,\n          version: version,\n          data: pData.slice()\n        };\n        this.#idb.q(({ blocks }) => {\n          blocks.put(block);\n          file.changedPages.add(iOffset);\n        }, 'rw', file.txOptions);\n      } else {\n        this.#idb.q(async ({ blocks }) => {\n          // Read the existing block.\n          const range = IDBKeyRange.bound(\n            [file.path, -iOffset],\n            [file.path, Infinity]);\n          const block = await blocks.get(range);\n\n          // Modify the block data.\n          // @ts-ignore\n          block.data.subarray(iOffset + block.offset).set(data);\n\n          // Write back.\n          blocks.put(block);\n        }, 'rw', file.txOptions);\n\n      }\n\n      if (file.metadata.fileSize < iOffset + pData.length) {\n        file.metadata.fileSize = iOffset + pData.length;\n        file.needsMetadataSync = true;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_WRITE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} iSize \n   * @returns {number}\n   */\n  jTruncate(fileId, iSize) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      if (iSize < file.metadata.fileSize) {\n        this.#idb.q(({ blocks }) => {\n          const range = IDBKeyRange.bound(\n            [file.path, -Infinity],\n            [file.path, -iSize, Infinity]);\n          blocks.delete(range);\n        }, 'rw', file.txOptions);\n        file.metadata.fileSize = iSize;\n        file.needsMetadataSync = true;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_TRUNCATE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {Promise<number>}\n   */\n  async jSync(fileId, flags) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      if (file.needsMetadataSync) {\n        this.#idb.q(({ metadata }) => metadata.put(file.metadata), 'rw', file.txOptions);\n        file.needsMetadataSync = false;\n      }\n\n      if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        // Sync is only needed here for durability. Visibility for other\n        // connections is ensured in jUnlock().\n        if (file.synchronous === 'full') {\n          await this.#idb.sync(true);\n        }\n      } else {\n        await this.#idb.sync(file.synchronous === 'full');\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_FSYNC;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pSize64 \n   * @returns {number}\n   */\n  jFileSize(fileId, pSize64) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      pSize64.setBigInt64(0, BigInt(file.metadata.fileSize), true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_FSTAT;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jLock(fileId, lockType) {\n    // Call the actual lock implementation.\n    const file = this.mapIdToFile.get(fileId);\n    const result = await super.jLock(fileId, lockType);\n\n    if (lockType === VFS.SQLITE_LOCK_SHARED) {\n      // Update metadata.\n      file.metadata = await this.#idb.q(async ({ metadata, blocks }) => {\n        // @ts-ignore\n        /** @type {Metadata} */ const m = await metadata.get(file.path);\n        if (m.pendingVersion) {\n          console.warn(`removing failed transaction ${m.pendingVersion}`);\n          await new Promise((resolve, reject) => {\n            const range = IDBKeyRange.bound([m.name, -Infinity], [m.name, Infinity]);\n            const request = blocks.openCursor(range);\n            request.onsuccess = () => {\n              const cursor = request.result;\n              if (cursor) {\n                const block = cursor.value;\n                if (block.version < m.version) {\n                  cursor.delete();\n                }\n                cursor.continue();\n              } else {\n                resolve();\n              }\n            };\n            request.onerror = () => reject(request.error);\n          })\n\n          delete m.pendingVersion;\n          metadata.put(m);\n        }\n        return m;\n      }, 'rw', file.txOptions);\n    }\n    return result;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jUnlock(fileId, lockType) {\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      const file = this.mapIdToFile.get(fileId);\n      await this.#idb.sync(file.synchronous === 'full');\n    }\n\n    // Call the actual unlock implementation.\n    return super.jUnlock(fileId, lockType);\n  }\n\n  /**\n   * @param {number} fileId\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(fileId, op, pArg) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      switch (op) {\n        case VFS.SQLITE_FCNTL_PRAGMA:\n          const key = extractString(pArg, 4);\n          const value = extractString(pArg, 8);\n          this.log?.('xFileControl', file.path, 'PRAGMA', key, value);\n          const setPragmaResponse = response => {\n            const encoded = new TextEncoder().encode(response);\n            const out = this._module._sqlite3_malloc(encoded.byteLength);\n            const outArray = this._module.HEAPU8.subarray(out, out + encoded.byteLength);\n            outArray.set(encoded);\n            pArg.setUint32(0, out, true);\n            return VFS.SQLITE_ERROR;\n          };\n          switch (key.toLowerCase()) {\n            case 'page_size':\n              if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n                // Don't allow changing the page size.\n                if (value && file.metadata.fileSize) {\n                  return VFS.SQLITE_ERROR;\n                }\n              }\n              break;\n            case 'synchronous':\n              if (value) {\n                switch (value.toLowerCase()) {\n                  case '0':\n                  case 'off':\n                    file.synchronous = 'off';\n                    file.txOptions = { durability: 'relaxed' };\n                    break;\n                  case '1':\n                  case 'normal':\n                    file.synchronous = 'normal';\n                    file.txOptions = { durability: 'relaxed' };\n                    break;\n                  case '2':\n                  case '3':\n                  case 'full':\n                  case 'extra':\n                    file.synchronous = 'full';\n                    file.txOptions = { durability: 'strict' };\n                    break;\n                }\n              }\n              break;\n            case 'write_hint':\n              return super.jFileControl(fileId, WebLocksMixin.WRITE_HINT_OP_CODE, null);\n            }\n          break;\n        case VFS.SQLITE_FCNTL_SYNC:\n          this.log?.('xFileControl', file.path, 'SYNC');\n          if (file.rollback) {\n            const commitMetadata = Object.assign({}, file.metadata);\n            const prevFileSize = file.rollback.fileSize\n            this.#idb.q(({ metadata, blocks }) => {\n              metadata.put(commitMetadata);\n\n              // Remove old page versions.\n              for (const offset of file.changedPages) {\n                if (offset < prevFileSize) {\n                  const range = IDBKeyRange.bound(\n                    [file.path, -offset, commitMetadata.version],\n                    [file.path, -offset, Infinity],\n                    true);\n                  blocks.delete(range);\n                }\n              }\n              file.changedPages.clear();\n            }, 'rw', file.txOptions);\n            file.needsMetadataSync = false;\n            file.rollback = null;\n          }\n          break;\n        case VFS.SQLITE_FCNTL_BEGIN_ATOMIC_WRITE:\n          // Every write transaction is atomic, so this is a no-op.\n          this.log?.('xFileControl', file.path, 'BEGIN_ATOMIC_WRITE');\n          return VFS.SQLITE_OK;\n        case VFS.SQLITE_FCNTL_COMMIT_ATOMIC_WRITE:\n          // Every write transaction is atomic, so this is a no-op.\n          this.log?.('xFileControl', file.path, 'COMMIT_ATOMIC_WRITE');\n          return VFS.SQLITE_OK;\n        case VFS.SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE:\n          this.log?.('xFileControl', file.path, 'ROLLBACK_ATOMIC_WRITE');\n          file.metadata = file.rollback;\n          const rollbackMetadata = Object.assign({}, file.metadata);\n          this.#idb.q(({ metadata, blocks }) => {\n            metadata.put(rollbackMetadata);\n\n            // Remove pages.\n            for (const offset of file.changedPages) {\n              blocks.delete([file.path, -offset, rollbackMetadata.version - 1]);\n            }\n            file.changedPages.clear();\n          }, 'rw', file.txOptions);\n          file.needsMetadataSync = false;\n          file.rollback = null;\n          return VFS.SQLITE_OK;\n      }\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR;\n    }\n    return super.jFileControl(fileId, op, pArg);\n  }\n  \n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jDeviceCharacteristics(pFile) {\n    return 0\n    | VFS.SQLITE_IOCAP_BATCH_ATOMIC\n    | VFS.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns {number|Promise<number>}\n   */\n  jGetLastError(zBuf) {\n    if (this.lastError) {\n      console.error(this.lastError);\n      const outputArray = zBuf.subarray(0, zBuf.byteLength - 1);\n      const { written } = new TextEncoder().encodeInto(this.lastError.message, outputArray);\n      zBuf[written] = 0;\n    }\n    return VFS.SQLITE_OK\n  }\n}\n\nfunction extractString(dataView, offset) {\n  const p = dataView.getUint32(offset, true);\n  if (p) {\n    const chars = new Uint8Array(dataView.buffer, p);\n    return new TextDecoder().decode(chars.subarray(0, chars.indexOf(0)));\n  }\n  return null;\n}\n\nexport class IDBContext {\n  /** @type {IDBDatabase} */ #database;\n\n  /** @type {Promise} */ #chain = null;\n  /** @type {Promise<any>} */ #txComplete = Promise.resolve();\n  /** @type {IDBRequest?} */ #request = null;\n  /** @type {WeakSet<IDBTransaction>} */ #txPending = new WeakSet();\n  \n  log = null;\n\n  static async create(name) {\n    const database = await new Promise((resolve, reject) => {\n      const request = indexedDB.open(name, 6);\n      request.onupgradeneeded = async event => {\n        const db = request.result;\n        if (event.oldVersion) {\n          console.log(`Upgrading IndexedDB from version ${event.oldVersion}`);\n        }\n        switch (event.oldVersion) {\n          case 0:\n            // Start with the original schema.\n            db.createObjectStore('blocks', { keyPath: ['path', 'offset', 'version']})\n              .createIndex('version', ['path', 'version']);\n            // fall through intentionally\n          case 5:\n            const tx = request.transaction;\n            const blocks = tx.objectStore('blocks');\n            blocks.deleteIndex('version');\n            const metadata = db.createObjectStore('metadata', { keyPath: 'name' });\n\n            await new Promise((resolve, reject) => {\n              // Iterate over all the blocks.\n              let lastBlock = {};\n              const request = tx.objectStore('blocks').openCursor();\n              request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                  const block = cursor.value;\n                  if (typeof block.offset !== 'number' ||\n                      (block.path === lastBlock.path && block.offset === lastBlock.offset)) {\n                    // Remove superceded block (or the \"purge\" info).\n                    cursor.delete();\n                  } else if (block.offset === 0) {\n                    // Move metadata to its own store.\n                    metadata.put({\n                      name: block.path,\n                      fileSize: block.fileSize,\n                      version: block.version\n                    });\n\n                    delete block.fileSize;\n                    cursor.update(block);\n                  }\n                  lastBlock = block;\n                  cursor.continue();\n                } else {\n                  resolve();\n                }\n              };\n              request.onerror = () => reject(request.error);\n            });\n            break;\n        }\n      };\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n    return new IDBContext(database);\n  }\n\n  constructor(database) {\n    this.#database = database;\n  }\n\n  close() {\n    this.#database.close();\n  }\n\n  /**\n   * @param {(stores: Object.<string, IDBObjectStore>) => any} f \n   * @param {'ro'|'rw'} mode \n   * @returns {Promise<any>}\n   */\n  q(f, mode = 'ro', options = {}) {\n    /** @type {IDBTransactionMode} */\n    const txMode = mode === 'ro' ? 'readonly' : 'readwrite';\n    const txOptions = Object.assign({\n      /** @type {IDBTransactionDurability} */ durability: 'default'\n    }, options);\n\n    // Ensure that queries run sequentially. If any function rejects,\n    // or any request has an error, or the transaction does not commit,\n    // then no subsequent functions will run until sync() or reset().\n    this.#chain = (this.#chain || Promise.resolve())\n      .then(() => this.#q(f, txMode, txOptions));\n    return this.#chain;\n  }\n\n  /**\n   * @param {(stores: Object.<string, IDBObjectStore>) => any} f \n   * @param {IDBTransactionMode} mode \n   * @param {IDBTransactionOptions} options\n   * @returns {Promise<any>}\n   */\n  async #q(f, mode, options) {\n    /** @type {IDBTransaction} */ let tx;\n    if (this.#request &&\n        this.#txPending.has(this.#request.transaction) &&\n        this.#request.transaction.mode >= mode &&\n        this.#request.transaction.durability === options.durability) {\n      // The previous request transaction is compatible and has\n      // not yet completed.\n      tx = this.#request.transaction;\n\n      // If the previous request is pending, wait for it to complete.\n      // This ensures that the transaction will be active.\n      if (this.#request.readyState === 'pending') {\n        await new Promise(resolve => {\n          this.#request.addEventListener('success', resolve, { once: true });\n          this.#request.addEventListener('error', resolve, { once: true });\n        });\n      }\n    }\n\n    for (let i = 0; i < 2; ++i) {\n      if (!tx) {\n        // The current transaction is missing or doesn't match so\n        // replace it with a new one. wait for the previous\n        // transaction to complete so the lifetimes do not overlap.\n        await this.#txComplete;\n\n        // Create the new transaction.\n        // @ts-ignore\n        tx = this.#database.transaction(this.#database.objectStoreNames, mode, options);\n        this.log?.('IDBTransaction open', mode);\n        this.#txPending.add(tx);\n        this.#txComplete = new Promise((resolve, reject) => {\n          tx.addEventListener('complete', () => {\n            this.log?.('IDBTransaction complete');\n            this.#txPending.delete(tx);\n            resolve();\n          });\n          tx.addEventListener('abort', () => {\n            this.#txPending.delete(tx);\n            reject(new Error('transaction aborted'));\n          });\n        });\n      }\n\n      try {\n        // @ts-ignore\n        // Create object store proxies.\n        const objectStores = [...tx.objectStoreNames].map(name => {\n          return [name, this.proxyStoreOrIndex(tx.objectStore(name))];\n        });\n\n        // Execute the function.\n        return await f(Object.fromEntries(objectStores));\n      } catch (e) {\n        // Use a new transaction if this one was inactive. This will\n        // happen if the last request in the transaction completed\n        // in a previous task but the transaction has not yet committed.\n        if (!i && RETRYABLE_ERRORS.has(e.name)) {\n          this.log?.(`${e.name}, retrying`);\n          tx = null;\n          continue;\n        }\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Object store methods that return an IDBRequest, except for cursor\n   * creation, are wrapped to return a Promise. In addition, the\n   * request is used internally for chaining.\n   * @param {IDBObjectStore} objectStore \n   * @returns \n   */\n  proxyStoreOrIndex(objectStore) {\n    return new Proxy(objectStore, {\n      get: (target, property, receiver) => {\n        const result = Reflect.get(target, property, receiver);\n        if (typeof result === 'function') {\n          return (...args) => {\n            const maybeRequest = Reflect.apply(result, target, args);\n            // @ts-ignore\n            if (maybeRequest instanceof IDBRequest && !property.endsWith('Cursor')) {\n              // // Debug logging.\n              // this.log?.(`${target.name}.${String(property)}`, args);\n              // maybeRequest.addEventListener('success', () => {\n              //   this.log?.(`${target.name}.${String(property)} success`, maybeRequest.result);\n              // });\n              // maybeRequest.addEventListener('error', () => {\n              //   this.log?.(`${target.name}.${String(property)} error`, maybeRequest.error);\n              // });\n              \n              // Save the request.\n              this.#request = maybeRequest;\n\n              // Abort the transaction on error.\n              maybeRequest.addEventListener('error', () => {\n                console.error(maybeRequest.error);\n                maybeRequest.transaction.abort();\n              }, { once: true });              \n\n              // Return a Promise.\n              return wrap(maybeRequest);\n            }\n            return maybeRequest;\n          }\n        }\n        return result;\n      }\n    });\n  }\n\n  /**\n   * @param {boolean} durable \n   */\n  async sync(durable) {\n    if (this.#chain) {\n      // This waits for all IndexedDB calls to be made.\n      await this.#chain;\n      if (durable) {\n        // This waits for the final transaction to commit.\n        await this.#txComplete;\n      }\n      this.reset();\n    }\n  }\n\n  reset() {\n    this.#chain = null;\n    this.#txComplete = Promise.resolve();\n    this.#request = null;\n  }\n}\n\n/**\n * @param {IDBRequest} request \n * @returns {Promise}\n */\nfunction wrap(request) {\n  return new Promise((resolve, reject) => {\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\n"],"names":[],"sourceRoot":""}